<!DOCTYPE html>
<html>
  <head>
    <style>
      /* Custom Scrollbar Styling */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #1a1a2e;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #7a8ef5 0%, #8659b3 100%);
      }

      body {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        padding: 20px;
        margin: 0;
      }

      .btn {
        padding: 12px 24px;
        font-size: 15px;
        font-weight: 500;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      }

      .btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-success {
        background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
        color: white;
      }

      .btn-danger {
        background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        color: white;
      }

      .btn-warning {
        background: linear-gradient(135deg, #f2994a 0%, #f2c94c 100%);
        color: white;
      }

      .btn-secondary {
        background: linear-gradient(135deg, #757f9a 0%, #d7dde8 100%);
        color: #333;
      }

      .btn-hide {
        background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%);
        color: white;
      }

      .btn-group {
        margin-bottom: 16px;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .shortcut {
        opacity: 0.8;
        font-size: 13px;
        font-weight: normal;
      }

      .select-wrapper {
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      select {
        padding: 10px 16px;
        font-size: 14px;
        background: #2a2a3e;
        color: white;
        border: 2px solid #444;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 200px;
      }

      select:hover {
        border-color: #667eea;
      }

      select:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      }

      .slide-dot {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: #444;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 12px;
        font-weight: 600;
        color: #888;
        border: 2px solid #555;
      }

      .slide-dot:hover {
        background: #555;
        border-color: #667eea;
        transform: scale(1.1);
      }

      .slide-dot.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #764ba2;
        transform: scale(1.15);
      }

      .slide-thumbnails {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 12px;
        margin-bottom: 20px;
        max-height: 600px;
        overflow-y: auto;
        padding: 10px;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
      }

      .slide-thumbnail {
        background: #2a2a3e;
        border: 3px solid #444;
        border-radius: 8px;
        padding: 30px 15px 15px 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        min-height: 150px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
      }

      .slide-thumbnail:hover {
        border-color: #667eea;
        transform: scale(1.02);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }

      .slide-thumbnail.active {
        border-color: #764ba2;
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
        box-shadow: 0 0 15px rgba(118, 75, 162, 0.5);
      }

      .slide-thumbnail-number {
        position: absolute;
        top: 5px;
        left: 8px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
      }

      .slide-thumbnail-content {
        font-size: 11px;
        color: #ccc;
        text-align: center;
        width: 100%;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .copyright-footer {
        position: fixed;
        bottom: 10px;
        right: 15px;
        font-size: 10px;
        color: #999;
        font-style: italic;
        z-index: 1000;
        pointer-events: none;
      }

      /* Visual Editor Modal */
      .editor-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 10000;
        overflow: auto;
      }

      .editor-content {
        margin: 20px auto;
        max-width: 1400px;
        background: #1a1a2e;
        border-radius: 12px;
        padding: 20px;
      }

      .editor-canvas {
        width: 1000px;
        height: 600px;
        background: #000 center/cover no-repeat;
        border: 2px solid #667eea;
        border-radius: 8px;
        position: relative;
        margin: 20px auto;
        overflow: hidden;
        cursor: crosshair;
      }
      
      .snap-guide {
        position: absolute;
        background: #a8e063;
        opacity: 0;
        transition: opacity 0.15s ease;
        pointer-events: none;
        z-index: 1;
      }
      
      .snap-guide.horizontal {
        width: 100%;
        height: 2px;
        left: 0;
        top: 50%;
        transform: translateY(-1px);
      }
      
      .snap-guide.vertical {
        width: 2px;
        height: 100%;
        left: 50%;
        top: 0;
        transform: translateX(-1px);
      }
      
      .snap-guide.visible {
        opacity: 0.8;
      }

      .text-element {
        position: absolute;
        color: white;
        cursor: move; /* show move cursor by default */
        padding: 10px;
        border: 2px dashed transparent;
        user-select: none; /* prevent text selection during drag */
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        outline: none; /* hide default outline on focus */
        z-index: 10; /* ensure text elements are above snap guides */
      }
      
      .text-element.editing {
        cursor: text; /* show text cursor when editing */
        user-select: text; /* allow text selection when editing */
      }

      .text-element:hover {
        border-color: #667eea;
        background: rgba(102, 126, 234, 0.1);
      }

      .text-element.selected {
        border-color: #a8e063;
        background: rgba(168, 224, 99, 0.1);
      }

      .editor-toolbar {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }

      .toolbar-group {
        display: flex;
        gap: 5px;
        align-items: center;
        background: #2a2a3e;
        padding: 8px;
        border-radius: 6px;
      }

      .toolbar-label {
        color: #aaa;
        font-size: 12px;
        margin-right: 5px;
      }

      .toolbar-input {
        padding: 5px 10px;
        background: #1a1a2e;
        color: white;
        border: 1px solid #444;
        border-radius: 4px;
        width: 80px;
      }

      .toolbar-btn {
        padding: 6px 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      /* brief flash to indicate save triggered */
      .flash-save {
        animation: flashSave 300ms ease-in-out;
        box-shadow: 0 0 8px rgba(102,126,234,0.8) !important;
      }
      @keyframes flashSave {
        0% { transform: translateY(0); }
        50% { transform: translateY(-2px) scale(1.02); }
        100% { transform: translateY(0); }
      }

      .toolbar-btn:hover {
        background: linear-gradient(135deg, #7a8ef5 0%, #8659b3 100%);
      }
    </style>
  </head>
  <body>
    <h2 style="margin-top:0; font-size:28px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">Control & Preview</h2>
    <div id="song-title" style="font-size:18px; font-weight:bold; margin-bottom:16px; color:#a8e063;"></div>
    
    <div class="btn-group">
      <button onclick="prevSlide()" class="btn btn-primary">
        ‚¨Ö Previous <span class="shortcut"></span>
      </button>
      <button onclick="nextSlide()" class="btn btn-primary">
        Next ‚û° / Space<span class="shortcut"></span>
      </button>
      <button id="projector-toggle" onclick="toggleProjector()" class="btn btn-success">
        üì∫ Open Projector <span class="shortcut">Alt+X</span>
      </button>
      <button id="projector-hide" onclick="toggleHideProjector()" class="btn btn-hide" style="display:none;">
        üëÅÔ∏è Show Projector <span class="shortcut">Alt+U</span>
      </button>
    </div>

    <div class="btn-group">
      <button onclick="decreaseFontSize()" class="btn btn-warning" title="Arrow Down">
        üî§‚ûñ Decrease Font Size (‚Üì)
      </button>
      <button onclick="resetFontSize()" class="btn btn-info" title="Ctrl+0">
        üî§‚Üª Reset Font Size (Ctrl+0)
      </button>
      <button onclick="increaseFontSize()" class="btn btn-warning" title="Arrow Up">
        üî§‚ûï Increase Font Size (‚Üë)
      </button>
    </div>

    <div id="image-zoom-controls" class="btn-group" style="display:none;">
      <button onclick="zoomOutImage()" class="btn btn-warning" title="Zoom Out Image">
        üîç‚ûñ Zoom Out
      </button>
      <button onclick="resetImageZoom()" class="btn btn-info" title="Reset Image Zoom">
        üîç‚Üª Reset Zoom
      </button>
      <button onclick="zoomInImage()" class="btn btn-warning" title="Zoom In Image">
        üîç‚ûï Zoom In
      </button>
    </div>

    <div style="display:flex; gap:10px;">
      <div class="select-wrapper" style="flex:1;">
        <label style="font-size:15px; font-weight:500;">üé® Service Background:</label>
        <select id="service-background-select" onchange="changeServiceBackground()">
          <option value="">No Background</option>
        </select>
      </div>

      <div class="select-wrapper" style="flex:1;">
        <label style="font-size:15px; font-weight:500;">üé® Hymnal Background:</label>
        <select id="background-select" onchange="changeBackground()">
          <option value="">No Background</option>
        </select>
      </div>
    </div>

    <div class="select-wrapper">
      <label style="font-size:15px; font-weight:500;">üìñ Bible Verse Background:</label>
      <select id="bible-background-select" onchange="changeBibleBackground()">
        <option value="">No Background</option>
      </select>
    </div>

    <div class="select-wrapper">
      <label style="font-size:15px; font-weight:500;">üî§ Display Font:</label>
      <select id="font-select" onchange="changeFont()">
        <option value="">Loading fonts...</option>
      </select>
    </div>


    <div id="slide-info" style="font-size:14px; margin-bottom:12px; color:#a0a0a0; font-weight:500; display:flex; align-items:center; gap:12px;">
      <span id="slide-counter"></span>
      <div id="slide-dots" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
    </div>

    <div id="slide-thumbnails" class="slide-thumbnails"></div>

    <script>
      const { ipcRenderer } = require('electron');
      let currentSlides = [];
      let currentIndex = 0;
      let currentSongName = '';
      let projectorOpen = false;
      let projectorHidden = false;
      let isServiceSlide = false; // Track if current slide is a service slide
      let isBibleVerse = false; // Track if current slide is a Bible verse

      // Load background images for all selectors
      async function loadBackgrounds() {
        const backgrounds = await ipcRenderer.invoke('get-backgrounds');
        
        // Populate hymnal background selector
        const hymnalSelect = document.getElementById('background-select');
        backgrounds.forEach(bg => {
          const option = document.createElement('option');
          option.value = bg;
          option.textContent = bg;
          hymnalSelect.appendChild(option);
        });
        
        // Populate service background selector
        const serviceSelect = document.getElementById('service-background-select');
        backgrounds.forEach(bg => {
          const option = document.createElement('option');
          option.value = bg;
          option.textContent = bg;
          serviceSelect.appendChild(option);
        });
        
        // Populate Bible verse background selector
        const bibleSelect = document.getElementById('bible-background-select');
        backgrounds.forEach(bg => {
          const option = document.createElement('option');
          option.value = bg;
          option.textContent = bg;
          bibleSelect.appendChild(option);
        });
        
        // Restore saved background selections from localStorage
        const savedHymnalBg = localStorage.getItem('hymnal-background');
        const savedServiceBg = localStorage.getItem('service-background');
        const savedBibleBg = localStorage.getItem('bible-background');
        
        if (savedHymnalBg) {
          hymnalSelect.value = savedHymnalBg;
        }
        if (savedServiceBg) {
          serviceSelect.value = savedServiceBg;
        }
        if (savedBibleBg) {
          bibleSelect.value = savedBibleBg;
        }
        // Apply selected background to editor canvas so user can preview placement
        const editorCanvasEl = document.getElementById('editorCanvas');
        const applyBg = async (filename) => {
          if (!filename) {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
            return;
          }
          const abs = await ipcRenderer.invoke('get-background-path', filename);
          if (abs) {
            // Use file:// path for CSS
            editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            editorCanvasEl.style.backgroundSize = 'cover';
            editorCanvasEl.style.backgroundPosition = 'center';
            editorCanvasEl.style.backgroundColor = '';
          }
        };
        // Apply hymnal/service/bible saved selection depending on which is active
        // Default to hymnal background if none selected for service
        const initialBg = savedServiceBg || savedHymnalBg || savedBibleBg || '';
        if (initialBg) applyBg(initialBg);
      }

      // Load system fonts
      async function loadFonts() {
        const fonts = await ipcRenderer.invoke('get-system-fonts');
        const fontSelect = document.getElementById('font-select');
        
        // Clear loading option
        fontSelect.innerHTML = '';
        
        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = 'Arial';
        defaultOption.textContent = 'Arial (Default)';
        fontSelect.appendChild(defaultOption);
        
        // Populate font selector
        fonts.forEach(font => {
          if (font !== 'Arial') { // Skip Arial since we already added it as default
            const option = document.createElement('option');
            option.value = font;
            option.textContent = font;
            // Apply the font to the option itself for preview
            option.style.fontFamily = font;
            fontSelect.appendChild(option);
          }
        });
        
        // Restore saved font selection from localStorage
        const savedFont = localStorage.getItem('display-font');
        if (savedFont) {
          fontSelect.value = savedFont;
          // Apply saved font immediately
          ipcRenderer.send('set-font', savedFont);
        } else {
          // Set default font
          ipcRenderer.send('set-font', 'Arial');
        }
      }

      // Change font
      async function changeFont() {
        const select = document.getElementById('font-select');
        const fontFamily = select.value;
        
        console.log('=== FONT CHANGE ===');
        console.log('Selected font:', fontFamily);
        
        // Save selection to localStorage
        localStorage.setItem('display-font', fontFamily);
        console.log('Saved to localStorage');
        
        // Send to projector window
        ipcRenderer.send('set-font', fontFamily);
        console.log('Sent set-font to main process');
        
        // Wait a moment for the font to be applied
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // If there's a current slide, re-show it with new font
        if (currentSlides.length > 0) {
          console.log('Re-displaying current slide with new font');
          showSlide();
        }
        
        // Visual feedback
        select.style.backgroundColor = '#2ecc71';
        setTimeout(() => {
          select.style.backgroundColor = '#2a2a3e';
        }, 300);
        
        console.log('===================');
      }

      // Change hymnal background
      function changeBackground() {
        const select = document.getElementById('background-select');
        const filename = select.value;
        
        // Save selection to localStorage
        localStorage.setItem('hymnal-background', filename);
        
        // Only apply if currently showing a hymnal slide
        if (!isServiceSlide && !isBibleVerse && currentSlides.length > 0) {
          ipcRenderer.send('set-background', filename);
          // Also apply to editor canvas for preview
          const editorCanvasEl = document.getElementById('editorCanvas');
          if (filename) {
            ipcRenderer.invoke('get-background-path', filename).then(abs => {
              if (abs) editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            });
          } else {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
          }
        }
        // Otherwise just store the selection for later use
      }

      // Change service background
      function changeServiceBackground() {
        const select = document.getElementById('service-background-select');
        const filename = select.value;
        
        // Save selection to localStorage
        localStorage.setItem('service-background', filename);
        
        // Only apply if currently showing a service slide
        if (isServiceSlide && currentSlides.length > 0) {
          ipcRenderer.send('set-background', filename);
          // Apply to editor canvas for preview
          const editorCanvasEl = document.getElementById('editorCanvas');
          if (filename) {
            ipcRenderer.invoke('get-background-path', filename).then(abs => {
              if (abs) editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            });
          } else {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
          }
        }
        // Otherwise just store the selection for later use
      }

      // Change Bible verse background
      function changeBibleBackground() {
        const select = document.getElementById('bible-background-select');
        const filename = select.value;
        
        // Save selection to localStorage
        localStorage.setItem('bible-background', filename);
        
        // Only apply if currently showing a Bible verse
        if (isBibleVerse && currentSlides.length > 0) {
          ipcRenderer.send('set-background', filename);
          // Apply to editor canvas for preview
          const editorCanvasEl = document.getElementById('editorCanvas');
          if (filename) {
            ipcRenderer.invoke('get-background-path', filename).then(abs => {
              if (abs) editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            });
          } else {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
          }
        }
        // Otherwise just store the selection for later use
      }

      // Listen for song loaded from list window
      ipcRenderer.on('song-loaded', (_, data) => {
        console.log('Song loaded:', data.name, 'Slides:', data.slides.length);
        currentSlides = data.slides;
        currentSongName = data.name;
        currentIndex = 0;
        
        // Detect if this is a service slide, Bible verse, or visual slide
        isServiceSlide = data.name.startsWith('Service:') || 
                        data.name.startsWith('Title:') || 
                        data.name === 'Visual Slide' ||
                        (data.slides.length > 0 && data.slides[0].type === 'visual');
        isBibleVerse = data.name.startsWith('Bible:');
        
        
        if (currentSlides.length > 0) {
          // Apply appropriate background when song loads
          if (isBibleVerse) {
            const select = document.getElementById('bible-background-select');
            const filename = select.value;
            if (filename) {
              ipcRenderer.send('set-background', filename);
            } else {
              // No Bible background selected, clear background
              ipcRenderer.send('set-background', '');
            }
          } else if (isServiceSlide) {
            const select = document.getElementById('service-background-select');
            const filename = select.value;
            if (filename) {
              ipcRenderer.send('set-background', filename);
            } else {
              // No service background selected, clear background
              ipcRenderer.send('set-background', '');
            }
          } else {
            const select = document.getElementById('background-select');
            const filename = select.value;
            if (filename) {
              ipcRenderer.send('set-background', filename);
            } else {
              // No hymnal background selected, use first available or clear
              ipcRenderer.send('set-background', '');
            }
          }
          createSlideDots();
          showSlide();
        }
      });

      function createSlideDots() {
        const dotsContainer = document.getElementById('slide-dots');
        dotsContainer.innerHTML = '';
        
        for (let i = 0; i < currentSlides.length; i++) {
          const dot = document.createElement('div');
          dot.className = 'slide-dot';
          dot.textContent = i + 1;
          dot.title = `Jump to slide ${i + 1}`;
          dot.onclick = () => jumpToSlide(i);
          dotsContainer.appendChild(dot);
        }
        
        // Create slide thumbnails
        createSlideThumbnails();
      }

      function createSlideThumbnails() {
        const thumbnailsContainer = document.getElementById('slide-thumbnails');
        thumbnailsContainer.innerHTML = '';
        
        for (let i = 0; i < currentSlides.length; i++) {
          const thumbnail = document.createElement('div');
          thumbnail.className = 'slide-thumbnail';
          if (i === currentIndex) {
            thumbnail.classList.add('active');
          }
          const number = document.createElement('div');
          number.className = 'slide-thumbnail-number';
          number.textContent = i + 1;
          const content = document.createElement('div');
          content.className = 'slide-thumbnail-content';
          const slideData = currentSlides[i];
          if (typeof slideData === 'object' && slideData.type === 'image') {
            // Display image thumbnail
            const img = document.createElement('img');
            img.src = `file:///${slideData.path.replace(/\\/g, '/')}`;
            img.style.cssText = 'max-width: 100%; max-height: 120px; object-fit: contain; border-radius: 4px;';
            content.appendChild(img);
          } else if (typeof slideData === 'object' && slideData.type === 'visual') {
            // Display canvas thumbnail for visual slide
            const canvas = document.createElement('canvas');
            // Larger drawing surface for clearer thumbnails
            canvas.width = 480; // high-res drawing surface
            canvas.height = 300;
            // Display size (CSS) - keep aspect ratio
            canvas.style.width = '240px';
            canvas.style.height = '150px';
            canvas.style.borderRadius = '6px';
            canvas.style.background = '#222';
            canvas.style.boxShadow = '0 1px 6px #0004';
            // Create an inner wrapper with fixed width so canvas and label stay centered
            const thumbInner = document.createElement('div');
            thumbInner.style.width = '240px';
            thumbInner.style.display = 'flex';
            thumbInner.style.flexDirection = 'column';
            thumbInner.style.alignItems = 'center';
            thumbInner.style.justifyContent = 'center';
            thumbInner.style.margin = '0 auto';
            thumbInner.appendChild(canvas);
            // Center the thumbnail block itself vertically/horizontally
            thumbnail.style.display = 'flex';
            thumbnail.style.flexDirection = 'column';
            thumbnail.style.alignItems = 'center';
            thumbnail.style.justifyContent = 'center';
            // Reduce extra top padding for visual thumbnails so canvas truly centers
            thumbnail.style.paddingTop = '15px';
            thumbnail.style.paddingBottom = '15px';
            // Center the canvas inside the thumbnail
            canvas.style.display = 'block';
            canvas.style.margin = '0 auto';
            // Use flex centering on content to be extra-safe
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.alignItems = 'center';
            content.style.justifyContent = 'center';
            content.style.gap = '8px';
            // Add a short preview label under the canvas
            const previewLabel = document.createElement('div');
            previewLabel.style.color = '#ccc';
            previewLabel.style.fontSize = '12px';
            previewLabel.style.textAlign = 'center';
            previewLabel.style.marginTop = '6px';
            previewLabel.style.width = '100%';
            let previewText = 'Visual Slide';
            if (slideData.elements && slideData.elements.length > 0 && slideData.elements[0].text) {
              previewText = slideData.elements[0].text.substring(0, 60);
              if (slideData.elements[0].text.length > 60) previewText += '...';
            }
            previewLabel.textContent = previewText;
            thumbInner.appendChild(previewLabel);
            // Center absolutely within the thumbnail container
            thumbInner.style.position = 'absolute';
            thumbInner.style.left = '50%';
            thumbInner.style.top = '50%';
            thumbInner.style.transform = 'translate(-50%, -50%)';
            // Ensure thumbnail is positioned (it already is via CSS) and append inner wrapper directly
            thumbnail.appendChild(thumbInner);
            // Draw elements
            setTimeout(() => {
              const ctx = canvas.getContext('2d');
              // Clear high-res canvas
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              let drawn = false;
              // Scale helper: map element positions from editor space to thumbnail
              const thumbW = canvas.width;
              const thumbH = canvas.height;
              // Use the real editor canvas size (fall back to 1000x600 if not available)
              const editorCanvasEl = document.getElementById('editorCanvas');
              const srcW = (editorCanvasEl && editorCanvasEl.clientWidth) ? editorCanvasEl.clientWidth : 1000;
              const srcH = (editorCanvasEl && editorCanvasEl.clientHeight) ? editorCanvasEl.clientHeight : 600;
              const scaleX = thumbW / srcW;
              const scaleY = thumbH / srcH;
              if (slideData.elements && slideData.elements.length > 0) {
                slideData.elements.forEach(el => {
                  if (el.type === 'rect') {
                    drawn = true;
                    ctx.fillStyle = el.color || '#4caf50';
                    const x = Math.max(0, Math.min(thumbW-10, (el.x || 10) * scaleX));
                    const y = Math.max(0, Math.min(thumbH-10, (el.y || 10) * scaleY));
                    const w = Math.max(10, Math.min(thumbW, (el.width || 200) * scaleX));
                    const h = Math.max(10, Math.min(thumbH, (el.height || 100) * scaleY));
                    ctx.fillRect(x, y, w, h);
                  } else if (el.type === 'text' && el.text) {
                    drawn = true;
                    // Font size scaled to thumbnail
                    const fontSize = Math.max(12, Math.floor((el.fontSize || 48) * Math.min(scaleX, scaleY)));
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.fillStyle = el.color || '#fff';
                    ctx.textBaseline = 'top';
                    // Estimate element box width if not provided
                    const estElemWidth = el.width || Math.min(srcW - (el.x || 0), (el.text.length * (el.fontSize || 48) * 0.6));
                    const scaledElemWidth = Math.max(20, estElemWidth * scaleX);
                    // Compute x based on alignment
                    let drawX = (el.x || 10) * scaleX;
                    let align = (el.align || 'left').toLowerCase();
                    if (align === 'center') {
                      ctx.textAlign = 'center';
                      drawX = drawX + scaledElemWidth / 2;
                    } else if (align === 'right') {
                      ctx.textAlign = 'right';
                      drawX = drawX + scaledElemWidth - 4;
                    } else {
                      ctx.textAlign = 'left';
                      drawX = drawX + 4;
                    }
                    const drawY = Math.max(4, Math.min(thumbH - 20, (el.y || 10) * scaleY));
                    // Truncate text to avoid overflow
                    let txt = el.text;
                    // Measure and trim to fit scaledElemWidth
                    if (ctx.measureText(txt).width > scaledElemWidth) {
                      while (txt.length > 0 && ctx.measureText(txt + '...').width > scaledElemWidth) {
                        txt = txt.slice(0, -1);
                      }
                      txt = txt + '...';
                    }
                    ctx.fillText(txt, drawX, drawY);
                    // reset textAlign to default for other elements
                    ctx.textAlign = 'start';
                  }
                });
              }
              if (!drawn) {
                ctx.font = 'bold 28px Arial';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('No Preview', thumbW/2, thumbH/2);
              }
            }, 0);
          } else {
            // Display text slide
            const slideText = typeof slideData === 'object' ? slideData.content : slideData;
            content.textContent = slideText;
          }
          thumbnail.appendChild(number);
          thumbnail.appendChild(content);
          thumbnail.onclick = () => jumpToSlide(i);
          thumbnailsContainer.appendChild(thumbnail);
        }
      }

      function jumpToSlide(index) {
        if (index >= 0 && index < currentSlides.length) {
          currentIndex = index;
          showSlide();
        }
      }

      function updateSlideDots() {
        const dots = document.querySelectorAll('.slide-dot');
        dots.forEach((dot, index) => {
          if (index === currentIndex) {
            dot.classList.add('active');
          } else {
            dot.classList.remove('active');
          }
        });
        
        // Also update thumbnails
        const thumbnails = document.querySelectorAll('.slide-thumbnail');
        thumbnails.forEach((thumbnail, index) => {
          if (index === currentIndex) {
            thumbnail.classList.add('active');
            // Scroll to active thumbnail
            thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          } else {
            thumbnail.classList.remove('active');
          }
        });
      }

      function showSlide() {
        if (currentSlides.length === 0) {
          console.log('No slides to show');
          return;
        }
        const slideData = currentSlides[currentIndex];
        
        console.log('Showing slide', currentIndex + 1, 'of', currentSlides.length);
        
        // Update UI
        document.getElementById('song-title').textContent = currentSongName;
        document.getElementById('slide-counter').textContent = `Slide ${currentIndex + 1} / ${currentSlides.length}`;
        
        // Update slide dots and thumbnails
        updateSlideDots();
        
        // Check slide type
        if (typeof slideData === 'object' && slideData.type === 'visual') {
          // Send visual slide with elements
          const payload = { 
            type: 'visual', 
            elements: slideData.elements,
            slideIndex: currentIndex, 
            totalSlides: currentSlides.length 
          };
          console.log('Control sending visual slide to projector:', payload);
          ipcRenderer.send('show-slide', payload);
        } else if (typeof slideData === 'object' && slideData.type === 'image') {
          // Send image path to projector
          const payload = { 
            type: 'image', 
            path: slideData.path,
            slideIndex: currentIndex, 
            totalSlides: currentSlides.length 
          };
          console.log('Control sending image to projector:', payload);
          ipcRenderer.send('show-slide', payload);
        } else {
          // Send text slide
          const text = typeof slideData === 'object' ? slideData.content : slideData;
          const payload = { 
            type: 'text',
            text, 
            slideIndex: currentIndex, 
            totalSlides: currentSlides.length 
          };
          console.log('Control sending text to projector:', text.substring(0, 50));
          ipcRenderer.send('show-slide', payload);
        }
      }

      function nextSlide() {
        console.log('Next clicked, current:', currentIndex, 'total:', currentSlides.length);
        if (currentIndex < currentSlides.length - 1) {
          currentIndex++;
          showSlide();
        } else {
          console.log('Already at last slide');
        }
      }

      function prevSlide() {
        console.log('Previous clicked, current:', currentIndex);
        if (currentIndex > 0) {
          currentIndex--;
          showSlide();
        } else {
          console.log('Already at first slide');
        }
      }

      function clearScreen() {
        console.log('clearScreen called');
        const preview = document.getElementById('preview');
        preview.innerHTML = `
          <div id="preview-overlay" style="position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); border-radius:10px;"></div>
          <div style="color:#666; position:relative; z-index:1;">Screen Cleared</div>
        `;
        currentSlideIndex = -1; // Reset slide index
        ipcRenderer.send('show-slide', '');
        console.log('Clear message sent to projector');
      }

      function toggleProjector() {
        console.log('Toggle projector - current state:', projectorOpen);
        if (projectorOpen) {
          console.log('Closing projector...');
          ipcRenderer.send('close-projector');
        } else {
          console.log('Opening projector...');
          ipcRenderer.send('open-projector');
        }
      }

      function updateProjectorButton(isOpen) {
        console.log('Updating projector button state to:', isOpen);
        projectorOpen = isOpen;
        const button = document.getElementById('projector-toggle');
        const hideButton = document.getElementById('projector-hide');
        
        if (isOpen) {
          button.innerHTML = '‚ùå Close Projector <span class="shortcut">Alt+X</span>';
          button.className = 'btn btn-warning';
          hideButton.style.display = 'inline-flex';
          updateHideButton(false); // Reset hide state when opening
        } else {
          button.innerHTML = 'üì∫ Open Projector <span class="shortcut">Alt+X</span>';
          button.className = 'btn btn-success';
          hideButton.style.display = 'none';
          projectorHidden = false;
        }
      }

      function toggleHideProjector() {
        if (projectorHidden) {
          ipcRenderer.send('show-projector');
        } else {
          ipcRenderer.send('hide-projector');
        }
      }

      function updateHideButton(isHidden) {
        projectorHidden = isHidden;
        const hideButton = document.getElementById('projector-hide');
        if (isHidden) {
          hideButton.innerHTML = 'üëÅÔ∏è Show Projector <span class="shortcut">Alt+U</span>';
          hideButton.className = 'btn btn-secondary';
        } else {
          hideButton.innerHTML = 'üôà Hide Projector <span class="shortcut">Alt+U</span>';
          hideButton.className = 'btn btn-hide';
        }
      }

      // Font size control functions - when editor is open, operate on editor elements
      function increaseFontSize() {
        const editorModal = document.getElementById('visualEditorModal');
        const fontInput = document.getElementById('fontSize');
        if (editorModal && editorModal.style.display === 'block' && fontInput) {
          let val = parseInt(fontInput.value) || 48;
          val = Math.min(300, val + 2);
          fontInput.value = val;
          updateSelectedElement();
          return;
        }
        ipcRenderer.send('adjust-font-size', 'increase');
      }

      function decreaseFontSize() {
        const editorModal = document.getElementById('visualEditorModal');
        const fontInput = document.getElementById('fontSize');
        if (editorModal && editorModal.style.display === 'block' && fontInput) {
          let val = parseInt(fontInput.value) || 48;
          val = Math.max(8, val - 2);
          fontInput.value = val;
          updateSelectedElement();
          return;
        }
        ipcRenderer.send('adjust-font-size', 'decrease');
      }

      function resetFontSize() {
        const editorModal = document.getElementById('visualEditorModal');
        const fontInput = document.getElementById('fontSize');
        if (editorModal && editorModal.style.display === 'block' && fontInput) {
          const val = 48;
          fontInput.value = val;
          updateSelectedElement();
          return;
        }
        ipcRenderer.send('adjust-font-size', 'reset');
      }

      // Keyboard shortcuts for font size control
      document.addEventListener('keydown', (event) => {
        // Arrow Up = Increase font size
        if (event.key === 'ArrowUp') {
          event.preventDefault();
          increaseFontSize();
        }
        // Arrow Down = Decrease font size
        else if (event.key === 'ArrowDown') {
          event.preventDefault();
          decreaseFontSize();
        }
        // Ctrl+0 = Reset font size
        else if (event.ctrlKey && event.key === '0') {
          event.preventDefault();
          resetFontSize();
        }
      });

      // Image zoom control functions
      function zoomInImage() {
        ipcRenderer.send('adjust-image-zoom', 'in');
      }

      function zoomOutImage() {
        ipcRenderer.send('adjust-image-zoom', 'out');
      }

      function resetImageZoom() {
        ipcRenderer.send('adjust-image-zoom', 'reset');
      }

      // Listen for projector state changes
      ipcRenderer.on('projector-state', (event, isOpen) => {
        updateProjectorButton(isOpen);
      });

      ipcRenderer.on('projector-visibility', (event, isHidden) => {
        updateHideButton(isHidden);
      });

      // Listen for image display state
      ipcRenderer.on('image-displayed', (event, isImage) => {
        const zoomControls = document.getElementById('image-zoom-controls');
        if (zoomControls) {
          zoomControls.style.display = isImage ? 'flex' : 'none';
        }
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Check if visual editor is open
        const editorModal = document.getElementById('visualEditorModal');
        const isEditorOpen = editorModal && editorModal.style.display === 'block';
        
        // If visual editor is open and user is editing text, allow normal spacebar behavior
        if (isEditorOpen) {
          const activeElement = document.activeElement;
          if (activeElement && activeElement.classList.contains('text-element')) {
            // User is editing text in visual editor, allow spacebar
            return;
          }
        }
        
        if (e.key === 'ArrowRight' || e.key === ' ') {
          e.preventDefault();
          nextSlide();
        }
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          prevSlide();
        }
        if (e.altKey && e.key.toLowerCase() === 'x') {
          e.preventDefault();
          toggleProjector();
        }
        if (e.altKey && e.key.toLowerCase() === 'u') {
          e.preventDefault();
          toggleHideProjector();
        }
      });

      // Visual Editor Variables
      let editorElements = [];
      let selectedElement = null;
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let elementIdCounter = 0;
      let currentEditingService = null;
      let editingVisualSlideIndex = -1;
      let editingVisualSlide = null;
      
      // Undo/Redo functionality
      let undoStack = [];
      let redoStack = [];
      
      // Save current state for undo
      function saveStateForUndo() {
        // Create a deep copy of current state
        const state = {
          elements: editorElements.map(el => ({...el})),
          elementIdCounter: elementIdCounter
        };
        undoStack.push(state);
        // Limit undo stack to 50 actions
        if (undoStack.length > 50) {
          undoStack.shift();
        }
        // Clear redo stack when new action is performed
        redoStack = [];
        console.log('State saved for undo. Stack size:', undoStack.length);
      }
      
      // Undo last action
      function undo() {
        if (undoStack.length === 0) {
          console.log('Nothing to undo');
          return;
        }
        
        // Save current state to redo stack
        const currentState = {
          elements: editorElements.map(el => ({...el})),
          elementIdCounter: elementIdCounter
        };
        redoStack.push(currentState);
        
        // Restore previous state
        const previousState = undoStack.pop();
        restoreState(previousState);
        console.log('Undo performed. Undo stack:', undoStack.length, 'Redo stack:', redoStack.length);
      }
      
      // Redo last undone action
      function redo() {
        if (redoStack.length === 0) {
          console.log('Nothing to redo');
          return;
        }
        
        // Save current state to undo stack
        const currentState = {
          elements: editorElements.map(el => ({...el})),
          elementIdCounter: elementIdCounter
        };
        undoStack.push(currentState);
        
        // Restore next state
        const nextState = redoStack.pop();
        restoreState(nextState);
        console.log('Redo performed. Undo stack:', undoStack.length, 'Redo stack:', redoStack.length);
      }
      
      // Restore state from snapshot
      function restoreState(state) {
        // Clear current elements
        clearCanvas();
        
        // Restore element counter
        elementIdCounter = state.elementIdCounter;
        
        // Restore elements
        editorElements = state.elements.map(el => ({...el}));
        
        // Re-render all elements
        const canvas = document.getElementById('editorCanvas');
        editorElements.forEach(elemData => {
          const element = document.createElement('div');
          element.className = 'text-element';
          element.id = elemData.id;
          element.textContent = elemData.text;
          element.style.left = elemData.x + 'px';
          element.style.top = elemData.y + 'px';
          element.style.fontSize = elemData.fontSize + 'px';
          element.style.color = elemData.color;
          element.style.textAlign = elemData.align;
          element.contentEditable = true;
          
          // Add event listeners
          element.addEventListener('mousedown', startDrag);
          element.addEventListener('click', selectElement);
          element.addEventListener('dblclick', enterEditMode);
          element.addEventListener('input', updateElementText);
          element.addEventListener('blur', finishEditing);
          
          canvas.appendChild(element);
        });
        
        // Clear selection
        selectedElement = null;
      }

      // Listen for open visual editor message from list window
      ipcRenderer.on('open-visual-editor', (_, data) => {
        console.log('Received open-visual-editor message:', data);
        currentEditingService = data.service;
        
        // Check if we're editing an existing slide (any type)
        if (data.editingSlide) {
          console.log('Editing existing slide:', data.editingSlide);
          editingVisualSlideIndex = data.editingIndex;
          editingVisualSlide = data.editingSlide;
        } else {
          editingVisualSlideIndex = -1;
          editingVisualSlide = null;
        }
        
        openVisualEditor();
      });

      // Helper function to clear canvas while preserving snap guides
      function clearCanvas() {
        const canvas = document.getElementById('editorCanvas');
        const elements = canvas.querySelectorAll('.text-element');
        elements.forEach(el => el.remove());
        
        // Ensure snap guides exist
        let snapGuideH = document.getElementById('snapGuideHorizontal');
        let snapGuideV = document.getElementById('snapGuideVertical');
        
        if (!snapGuideH) {
          snapGuideH = document.createElement('div');
          snapGuideH.id = 'snapGuideHorizontal';
          snapGuideH.className = 'snap-guide horizontal';
          canvas.appendChild(snapGuideH);
        }
        
        if (!snapGuideV) {
          snapGuideV = document.createElement('div');
          snapGuideV.id = 'snapGuideVertical';
          snapGuideV.className = 'snap-guide vertical';
          canvas.appendChild(snapGuideV);
        }
      }

      // Open Visual Editor
      function openVisualEditor() {
        document.getElementById('visualEditorModal').style.display = 'block';
        
        // Clear previous content
        editorElements = [];
        selectedElement = null;
        clearCanvas();
        elementIdCounter = 0;
        
        // Clear undo/redo stacks
        undoStack = [];
        redoStack = [];
        
        // If editing existing slide (any type), load its content
        if (editingVisualSlide) {
          console.log('Loading existing slide elements:', editingVisualSlide);
          loadExistingVisualSlide();
        }
        // Initialize toolbar font size to default or to first element's fontSize
        const fontInput = document.getElementById('fontSize');
        if (fontInput) {
          let defaultSize = 48;
          if (editingVisualSlide && editingVisualSlide.elements && editingVisualSlide.elements.length > 0) {
            const first = editingVisualSlide.elements[0];
            if (first && first.fontSize) defaultSize = first.fontSize;
          }
          fontInput.value = defaultSize;
        }
      }

      // Close Visual Editor
      function closeVisualEditor() {
        document.getElementById('visualEditorModal').style.display = 'none';
        editorElements = [];
        selectedElement = null;
        clearCanvas();
        editingVisualSlideIndex = -1;
        editingVisualSlide = null;
        
        // Clear undo/redo stacks
        undoStack = [];
        redoStack = [];
      }

      // Add Text Element
      function addTextElement() {
        saveStateForUndo(); // Save state before adding element
        
        const canvas = document.getElementById('editorCanvas');
        const element = document.createElement('div');
        element.className = 'text-element';
        element.id = 'element-' + (elementIdCounter++);
        element.textContent = 'Click to edit';
        element.style.left = '50px';
        element.style.top = '50px';
        const toolbarFont = document.getElementById('fontSize');
        const initialFont = (toolbarFont && toolbarFont.value) ? parseInt(toolbarFont.value) : 48;
        element.style.fontSize = initialFont + 'px';
        element.style.color = '#ffffff';
        element.style.textAlign = 'center';
        element.contentEditable = true; // Make directly editable
        element.setAttribute('data-placeholder', 'Click to edit');
        
        // Add event listeners
        element.addEventListener('mousedown', startDrag);
        element.addEventListener('click', selectElement);
        element.addEventListener('dblclick', enterEditMode);
        element.addEventListener('input', updateElementText);
        element.addEventListener('blur', finishEditing);
        
        canvas.appendChild(element);
        editorElements.push({
          id: element.id,
          text: element.textContent,
          x: 50,
          y: 50,
          fontSize: initialFont,
          color: '#ffffff',
          align: 'center'
        });
        
        selectElement({ target: element });
        // Start in editing mode for new elements
        element.classList.add('editing');
        element.focus(); // Focus for immediate editing
      }

      // Select Element
      function selectElement(e) {
        if (selectedElement) {
          selectedElement.classList.remove('selected');
        }
        selectedElement = e.target.closest('.text-element');
        if (selectedElement) {
          selectedElement.classList.add('selected');
          
          // Update toolbar with element properties
          document.getElementById('fontSize').value = parseInt(selectedElement.style.fontSize);
          document.getElementById('textColor').value = rgbToHex(selectedElement.style.color);
        }
      }
      
      // Enter editing mode on double-click
      function enterEditMode(e) {
        if (e.target.classList.contains('text-element')) {
          e.target.classList.add('editing');
          e.target.focus();
          // Select all text for easy replacement
          const range = document.createRange();
          range.selectNodeContents(e.target);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
      
      // Exit editing mode
      function exitEditMode(element) {
        if (element && element.classList.contains('text-element')) {
          element.classList.remove('editing');
        }
      }

      // Start Drag
      function startDrag(e) {
        if (e.target.classList.contains('text-element')) {
          // Check if element is in editing mode
          if (e.target.classList.contains('editing')) {
            // Already editing, allow text interaction
            return;
          }

          // Save state before dragging
          saveStateForUndo();
          
          // Start dragging
          isDragging = true;
          selectedElement = e.target;
          selectElement(e);
          
          const rect = selectedElement.getBoundingClientRect();
          const canvasRect = document.getElementById('editorCanvas').getBoundingClientRect();
          // Calculate offset as the mouse position relative to the element's top-left
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          
          document.addEventListener('mousemove', drag);
          document.addEventListener('mouseup', stopDrag);
          
          e.preventDefault();
        }
      }

      // Drag
      function drag(e) {
        if (isDragging && selectedElement) {
          const canvasRect = document.getElementById('editorCanvas').getBoundingClientRect();
          // Calculate new position: mouse position relative to canvas minus the offset
          let x = e.clientX - canvasRect.left - dragOffsetX;
          let y = e.clientY - canvasRect.top - dragOffsetY;
          
          // Keep within bounds
          x = Math.max(0, Math.min(x, canvasRect.width - selectedElement.offsetWidth));
          y = Math.max(0, Math.min(y, canvasRect.height - selectedElement.offsetHeight));
          
          // Snap to center functionality
          const snapThreshold = 15; // pixels
          const canvasCenterX = canvasRect.width / 2;
          const canvasCenterY = canvasRect.height / 2;
          const elementCenterX = x + selectedElement.offsetWidth / 2;
          const elementCenterY = y + selectedElement.offsetHeight / 2;
          
          const snapGuideH = document.getElementById('snapGuideHorizontal');
          const snapGuideV = document.getElementById('snapGuideVertical');
          
          // Check horizontal center snap
          if (Math.abs(elementCenterY - canvasCenterY) < snapThreshold) {
            y = canvasCenterY - selectedElement.offsetHeight / 2;
            snapGuideH.classList.add('visible');
          } else {
            snapGuideH.classList.remove('visible');
          }
          
          // Check vertical center snap
          if (Math.abs(elementCenterX - canvasCenterX) < snapThreshold) {
            x = canvasCenterX - selectedElement.offsetWidth / 2;
            snapGuideV.classList.add('visible');
          } else {
            snapGuideV.classList.remove('visible');
          }
          
          selectedElement.style.left = x + 'px';
          selectedElement.style.top = y + 'px';
          
          // Update in elements array
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.x = x;
            elemData.y = y;
          }
        }
      }

      // Stop Drag
      function stopDrag() {
        isDragging = false;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);
        
        // Hide snap guides when drag stops
        const snapGuideH = document.getElementById('snapGuideHorizontal');
        const snapGuideV = document.getElementById('snapGuideVertical');
        if (snapGuideH) snapGuideH.classList.remove('visible');
        if (snapGuideV) snapGuideV.classList.remove('visible');
      }

      // Update element text when content changes
      function updateElementText(e) {
        const element = e.target;
        const elemData = editorElements.find(el => el.id === element.id);
        if (elemData) {
          elemData.text = element.textContent;
        }
      }

      // Finish editing when element loses focus
      function finishEditing(e) {
        const element = e.target;
        const elemData = editorElements.find(el => el.id === element.id);
        if (elemData) {
          elemData.text = element.textContent;
        }
        // Exit editing mode
        exitEditMode(element);
      }

      // Update Selected Element
      function updateSelectedElement() {
        if (selectedElement) {
          const fontSize = document.getElementById('fontSize').value;
          const textColor = document.getElementById('textColor').value;
          // Preserve visual center when changing font size
          const oldWidth = selectedElement.offsetWidth;
          const oldLeft = parseFloat(selectedElement.style.left) || 0;
          const align = selectedElement.style.textAlign || 'center';

          selectedElement.style.fontSize = fontSize + 'px';
          selectedElement.style.color = textColor;

          // After font change, compute new width and adjust left to keep centered/right alignment visually stable
          const newWidth = selectedElement.offsetWidth;
          const delta = newWidth - oldWidth;
          if (align === 'center') {
            // Move left by half the width increase so center remains at same position
            selectedElement.style.left = (oldLeft - delta / 2) + 'px';
          } else if (align === 'right') {
            // Move left by full delta so right edge stays anchored
            selectedElement.style.left = (oldLeft - delta) + 'px';
          }
          
          // Update in elements array
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.fontSize = parseInt(fontSize);
            elemData.color = textColor;
            elemData.x = parseFloat(selectedElement.style.left) || elemData.x;
          }
        }
      }

      // Align Text (inside the text box)
      function alignText(alignment) {
        if (selectedElement) {
          saveStateForUndo(); // Save state before aligning
          
          selectedElement.style.textAlign = alignment;
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.align = alignment;
          }
          console.log('Aligned text to:', alignment);
        }
      }
      
      // Align Text Box Horizontally (position on canvas)
      function alignBoxHorizontal(alignment) {
        if (selectedElement) {
          saveStateForUndo(); // Save state before aligning
          
          const canvasRect = document.getElementById('editorCanvas').getBoundingClientRect();
          const canvasWidth = canvasRect.width;
          const boxWidth = selectedElement.offsetWidth;
          let newX;
          
          switch(alignment) {
            case 'left':
              newX = 0;
              break;
            case 'center':
              newX = (canvasWidth - boxWidth) / 2;
              break;
            case 'right':
              newX = canvasWidth - boxWidth;
              break;
          }
          
          selectedElement.style.left = newX + 'px';
          
          // Update in elements array
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.x = newX;
          }
          console.log('Aligned box horizontally to:', alignment);
        }
      }
      
      // Align Text Box Vertically (position on canvas)
      function alignBoxVertical(alignment) {
        if (selectedElement) {
          saveStateForUndo(); // Save state before aligning
          
          const canvasRect = document.getElementById('editorCanvas').getBoundingClientRect();
          const canvasHeight = canvasRect.height;
          const boxHeight = selectedElement.offsetHeight;
          let newY;
          
          switch(alignment) {
            case 'top':
              newY = 0;
              break;
            case 'middle':
              newY = (canvasHeight - boxHeight) / 2;
              break;
            case 'bottom':
              newY = canvasHeight - boxHeight;
              break;
          }
          
          selectedElement.style.top = newY + 'px';
          
          // Update in elements array
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.y = newY;
          }
          console.log('Aligned box vertically to:', alignment);
        }
      }

      // Delete Selected Element
      function deleteSelectedElement() {
        if (selectedElement) {
          saveStateForUndo(); // Save state before deleting
          
          const index = editorElements.findIndex(el => el.id === selectedElement.id);
          if (index > -1) {
            editorElements.splice(index, 1);
          }
          selectedElement.remove();
          selectedElement = null;
        }
      }

      // RGB to Hex converter
      function rgbToHex(rgb) {
        if (rgb.startsWith('#')) return rgb;
        const result = rgb.match(/\d+/g);
        if (!result) return '#ffffff';
        return '#' + result.map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
      }

      // Save Service Slide
      function saveServiceSlide() {
        if (editorElements.length === 0) {
          console.log('No elements to save');
          return;
        }
        
        // Convert elements to service slide format
        const slideData = {
          type: 'visual',
          service: currentEditingService,
          elements: editorElements.map(el => ({
            type: el.type || 'text',
            text: el.text,
            x: el.x,
            y: el.y,
            fontSize: el.fontSize,
            color: el.color,
            align: el.align,
            width: el.width,
            height: el.height
          }))
        };
        
        // If editing existing slide, include the editing index
        if (editingVisualSlideIndex >= 0) {
          slideData.editingIndex = editingVisualSlideIndex;
          console.log('Updating existing slide at index:', editingVisualSlideIndex);
          
          // If a visual slide is currently displayed, update Display2 immediately
          // Check if currentSlides has a visual slide (usually only 1 slide when displaying visual)
          if (currentSlides.length > 0 && currentSlides[currentIndex] && 
              currentSlides[currentIndex].type === 'visual') {
            console.log('Visual slide is currently displayed, refreshing Display2');
            // Update the slide in currentSlides array
            currentSlides[currentIndex] = {
              type: 'visual',
              elements: slideData.elements
            };
            // Send updated slide to projector
            const payload = { 
              type: 'visual', 
              elements: slideData.elements,
              slideIndex: currentIndex, 
              totalSlides: currentSlides.length 
            };
            console.log('Sending refresh to projector:', payload);
            ipcRenderer.send('show-slide', payload);
          }
        } else {
          console.log('Creating new visual slide');
        }
        
        console.log('Saving service slide:', slideData);
        
        // Send to main process to forward to list window
        ipcRenderer.send('save-visual-slide', slideData);
        
        // Clear and close editor
        editorElements = [];
        selectedElement = null;
        clearCanvas();
        document.getElementById('visualEditorModal').style.display = 'none';
        editingVisualSlideIndex = -1;
        editingVisualSlide = null;
      }

      // Load Existing Slide (handles all slide types)
      function loadExistingVisualSlide() {
        if (!editingVisualSlide) {
          console.log('No slide data to load');
          return;
        }
        
        const canvas = document.getElementById('editorCanvas');
        
        if (editingVisualSlide.type === 'visual' && editingVisualSlide.elements) {
          // Load existing visual slide elements
          editingVisualSlide.elements.forEach((elementData, index) => {
            const element = document.createElement('div');
            element.className = 'text-element';
            element.id = 'element-' + (elementIdCounter++);
            element.textContent = elementData.text;
            element.style.left = elementData.x + 'px';
            element.style.top = elementData.y + 'px';
            element.style.fontSize = elementData.fontSize + 'px';
            element.style.color = elementData.color;
            element.style.textAlign = elementData.align;
            element.contentEditable = true; // Make directly editable
            
            // Add event listeners
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('click', selectElement);
            element.addEventListener('dblclick', enterEditMode);
            element.addEventListener('input', updateElementText);
            element.addEventListener('blur', finishEditing);
            
            canvas.appendChild(element);
            
            // Add to editor elements array
            editorElements.push({
              id: element.id,
              text: elementData.text,
              x: elementData.x,
              y: elementData.y,
              fontSize: elementData.fontSize,
              color: elementData.color,
              align: elementData.align
            });
          });
          console.log('Loaded', editorElements.length, 'visual elements');
          // Set toolbar font size to first element's font size if present
          const fontInput = document.getElementById('fontSize');
          if (fontInput && editorElements.length > 0) {
            fontInput.value = editorElements[0].fontSize || parseInt(fontInput.value) || 48;
          }
        } else {
          // Convert other slide types to visual elements
          let elements = [];
          
          if (editingVisualSlide.type === 'title') {
            // Convert title slide to visual elements
            if (editingVisualSlide.titleText) {
              elements.push({
                text: editingVisualSlide.titleText,
                x: 100,
                y: 200,
                fontSize: 72,
                color: '#ffffff',
                align: 'center'
              });
            }
            if (editingVisualSlide.titleSubtitle) {
              elements.push({
                text: editingVisualSlide.titleSubtitle,
                x: 100,
                y: 300,
                fontSize: 48,
                color: '#a8e063',
                align: 'center'
              });
            }
          } else if (editingVisualSlide.type === 'bible') {
            // Convert bible verse to visual elements
            if (editingVisualSlide.verseText) {
              elements.push({
                text: `"${editingVisualSlide.verseText}"`,
                x: 100,
                y: 200,
                fontSize: 48,
                color: '#ffffff',
                align: 'center'
              });
            }
            if (editingVisualSlide.reference) {
              elements.push({
                text: editingVisualSlide.reference,
                x: 100,
                y: 400,
                fontSize: 36,
                color: '#a8e063',
                align: 'center'
              });
            }
          } else {
            // Convert normal slide to visual elements
            if (editingVisualSlide.position) {
              elements.push({
                text: editingVisualSlide.position,
                x: 100,
                y: 150,
                fontSize: 60,
                color: '#ffffff',
                align: 'center'
              });
            }
            if (editingVisualSlide.title) {
              elements.push({
                text: editingVisualSlide.title,
                x: 100,
                y: 250,
                fontSize: 48,
                color: '#a8e063',
                align: 'center'
              });
            }
            if (editingVisualSlide.name) {
              elements.push({
                text: editingVisualSlide.name,
                x: 100,
                y: 350,
                fontSize: 42,
                color: '#ffffff',
                align: 'center'
              });
            }
          }
          
          // Create visual elements from converted data
          elements.forEach((elementData, index) => {
            const element = document.createElement('div');
            element.className = 'text-element';
            element.id = 'element-' + (elementIdCounter++);
            element.textContent = elementData.text;
            element.style.left = elementData.x + 'px';
            element.style.top = elementData.y + 'px';
            element.style.fontSize = elementData.fontSize + 'px';
            element.style.color = elementData.color;
            element.style.textAlign = elementData.align;
            element.contentEditable = true; // Make directly editable
            
            // Add event listeners
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('click', selectElement);
            element.addEventListener('dblclick', enterEditMode);
            element.addEventListener('input', updateElementText);
            element.addEventListener('blur', finishEditing);
            
            canvas.appendChild(element);
            
            // Add to editor elements array
            editorElements.push({
              id: element.id,
              text: elementData.text,
              x: elementData.x,
              y: elementData.y,
              fontSize: elementData.fontSize,
              color: elementData.color,
              align: elementData.align
            });
          });
          // Set toolbar font size to first converted element's font size
          const fontInput2 = document.getElementById('fontSize');
          if (fontInput2 && editorElements.length > 0) {
            fontInput2.value = editorElements[0].fontSize || parseInt(fontInput2.value) || 48;
          }
          
          console.log('Converted', editingVisualSlide.type, 'slide to', editorElements.length, 'visual elements');
        }
      }


      // Keyboard event handling for visual editor
      document.addEventListener('keydown', (e) => {
        // Only handle keys when visual editor is open
        const editorModal = document.getElementById('visualEditorModal');
        const saveBtn = document.getElementById('editor-save-btn');
        // Ctrl/Cmd+S save shortcut
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
          if (editorModal && editorModal.style.display === 'block') {
            e.preventDefault();
            // Trigger save and give visual feedback
            if (saveBtn) {
              saveBtn.classList.add('flash-save');
              setTimeout(() => saveBtn.classList.remove('flash-save'), 300);
            }
            saveServiceSlide();
            return;
          }
        }

        // Escape key: if editor open, close it; if a text element is being edited, exit edit mode instead
        if (e.key === 'Escape') {
          if (editorModal && editorModal.style.display === 'block') {
            const active = document.activeElement;
            if (active && active.classList && active.classList.contains('text-element') && active.classList.contains('editing')) {
              // Exit editing mode for the active text element
              active.classList.remove('editing');
              // trigger blur to persist changes
              try { active.blur(); } catch (err) {}
              return;
            }
            e.preventDefault();
            closeVisualEditor();
            return;
          }
        }
        if (editorModal && editorModal.style.display === 'block') {
          // Undo: Ctrl+Z
          if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
            return;
          }
          
          // Redo: Ctrl+Y or Ctrl+Shift+Z
          if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'Z')) {
            e.preventDefault();
            redo();
            return;
          }
          
          if ((e.key === 'Delete' || e.key === 'Backspace')) {
            // If caret is inside an editable element, let browser handle Backspace/Delete
            const active = document.activeElement;
            if (active && active.classList && active.classList.contains('text-element')) {
              return; // allow native text deletion
            }
            e.preventDefault();
            deleteSelectedElement();
          }
        }
      });

      // Initialize
      loadBackgrounds();
      loadFonts();
    </script>
    
    <div class="copyright-footer">¬© 2025 Songnam Saraphai. All rights reserved.</div>

    <!-- Visual Editor Modal -->
    <div id="visualEditorModal" class="editor-modal">
      <div class="editor-content">
        <h2 style="margin-top:0; color:#a8e063;">üé® Visual Service Slide Editor</h2>
        
        <div class="editor-toolbar">
          <div class="toolbar-group">
            <button class="toolbar-btn" onclick="addTextElement()">‚ûï Add Text</button>
          </div>
          
          <div class="toolbar-group">
            <span class="toolbar-label">Font Size:</span>
            <input type="number" id="fontSize" class="toolbar-input" value="48" min="12" max="200" onchange="updateSelectedElement()">
          </div>
          
          <div class="toolbar-group">
            <span class="toolbar-label">Color:</span>
            <input type="color" id="textColor" class="toolbar-input" value="#ffffff" onchange="updateSelectedElement()">
          </div>
          
          <!-- Removed Text Align controls -->
          
          <div class="toolbar-group">
            <span class="toolbar-label">Position Box:</span>
            <button class="toolbar-btn" onclick="alignBoxHorizontal('left')" title="Align box to left">‚¨Ö</button>
            <button class="toolbar-btn" onclick="alignBoxHorizontal('center')" title="Center box horizontally">‚Üî</button>
            <button class="toolbar-btn" onclick="alignBoxHorizontal('right')" title="Align box to right">‚û°</button>
            <button class="toolbar-btn" onclick="alignBoxVertical('top')" title="Align box to top">‚¨Ü</button>
            <button class="toolbar-btn" onclick="alignBoxVertical('middle')" title="Center box vertically">‚Üï</button>
            <button class="toolbar-btn" onclick="alignBoxVertical('bottom')" title="Align box to bottom">‚¨á</button>
          </div>
          
          <div class="toolbar-group">
            <button id="editor-save-btn" class="toolbar-btn" onclick="saveServiceSlide()">üíæ Save</button>
            <button class="toolbar-btn" onclick="closeVisualEditor()">‚ùå Close</button>
          </div>
        </div>

        <div id="editorCanvas" class="editor-canvas">
          <div id="snapGuideHorizontal" class="snap-guide horizontal"></div>
          <div id="snapGuideVertical" class="snap-guide vertical"></div>
        </div>

        <div style="margin-top:10px; color:#aaa; font-size:12px;">
          üí° <strong>Tips:</strong> <strong>Drag</strong> to move (snaps to center). <strong>Double-click</strong> to edit. <strong>Ctrl+Z</strong> to undo, <strong>Ctrl+Y</strong> to redo. <strong>Delete</strong> to remove. Use align buttons for positioning.
        </div>
      </div>
    </div>
  </body>
</html>
