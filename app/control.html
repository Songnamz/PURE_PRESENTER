<!DOCTYPE html>
<html>
  <head>
    <style>
      /* Custom Scrollbar Styling */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #1a1a2e;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #7a8ef5 0%, #8659b3 100%);
      }

      body {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        padding: 20px;
        margin: 0;
      }

      .btn {
        padding: 12px 24px;
        font-size: 15px;
        font-weight: 500;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      }

      .btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-success {
        background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
        color: white;
      }

      .btn-danger {
        background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        color: white;
      }

      .btn-warning {
        background: linear-gradient(135deg, #f2994a 0%, #f2c94c 100%);
        color: white;
      }

      .btn-secondary {
        background: linear-gradient(135deg, #757f9a 0%, #d7dde8 100%);
        color: #333;
      }

      .btn-hide {
        background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%);
        color: white;
      }

      .btn-group {
        margin-bottom: 16px;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .shortcut {
        opacity: 0.8;
        font-size: 13px;
        font-weight: normal;
      }

      .select-wrapper {
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      select {
        padding: 10px 16px;
        font-size: 14px;
        background: #2a2a3e;
        color: white;
        border: 2px solid #444;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 200px;
      }

      select:hover {
        border-color: #667eea;
      }

      select:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      }

      .slide-dot {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: #444;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 12px;
        font-weight: 600;
        color: #888;
        border: 2px solid #555;
      }

      .slide-dot:hover {
        background: #555;
        border-color: #667eea;
        transform: scale(1.1);
      }

      .slide-dot.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #764ba2;
        transform: scale(1.15);
      }

      .slide-thumbnails {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 12px;
        margin-bottom: 20px;
        max-height: 600px;
        overflow-y: auto;
        padding: 10px;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
      }

      .slide-thumbnail {
        background: #2a2a3e;
        border: 3px solid #444;
        border-radius: 8px;
        padding: 30px 15px 15px 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        min-height: 150px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
      }

      .slide-thumbnail:hover {
        border-color: #667eea;
        transform: scale(1.02);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }

      .slide-thumbnail.active {
        border-color: #764ba2;
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
        box-shadow: 0 0 15px rgba(118, 75, 162, 0.5);
      }

      .slide-thumbnail-number {
        position: absolute;
        top: 5px;
        left: 8px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
      }

      .slide-thumbnail-content {
        font-size: 11px;
        color: #ccc;
        text-align: center;
        width: 100%;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .copyright-footer {
        position: fixed;
        bottom: 10px;
        right: 15px;
        font-size: 10px;
        color: #999;
        font-style: italic;
        z-index: 1000;
        pointer-events: none;
      }

      /* Visual Editor Modal */
      .editor-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 10000;
        overflow: auto;
      }

      .editor-content {
        margin: 20px auto;
        max-width: 1400px;
        background: #1a1a2e;
        border-radius: 12px;
        padding: 20px;
      }

      .editor-canvas {
        width: 960px;
        height: 540px;
        background: #000 center/cover no-repeat;
        border: 2px solid #667eea;
        border-radius: 8px;
        position: relative;
        margin: 20px auto;
        overflow: hidden;
        cursor: crosshair;
      }
      /* Light grid overlay for alignment */
      .editor-canvas.grid-on::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(to right, rgba(255,255,255,0.04) 1px, transparent 1px), linear-gradient(to bottom, rgba(255,255,255,0.04) 1px, transparent 1px);
        background-size: 20px 20px;
        pointer-events: none;
        z-index: 2;
      }
      
      .snap-guide {
        position: absolute;
        background: #a8e063;
        opacity: 0;
        transition: opacity 0.15s ease;
        pointer-events: none;
        z-index: 1;
      }
      
      .snap-guide.horizontal {
        width: 100%;
        height: 2px;
        left: 0;
        top: 50%;
        transform: translateY(-1px);
      }
      
      .snap-guide.vertical {
        width: 2px;
        height: 100%;
        left: 50%;
        top: 0;
        transform: translateX(-1px);
      }
      
      .snap-guide.visible {
        opacity: 0.8;
      }

      .text-element {
        position: absolute;
        color: white;
        cursor: move;
        padding: 10px;
        border: 2px dashed transparent;
        user-select: none;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        outline: none;
        z-index: 10;
        text-align: center; /* Default center align */
        transform: translate(-50%, -50%); /* Position based on center */
      }
      
      .text-element.editing {
        cursor: text; /* show text cursor when editing */
        user-select: text; /* allow text selection when editing */
      }

      .text-element:hover {
        border-color: #667eea;
        background: rgba(102, 126, 234, 0.1);
      }

      .text-element.selected {
        border-color: #a8e063;
        background: rgba(168, 224, 99, 0.1);
      }

      /* Resize handle inside text element */
      .text-element .resizer {
        position: absolute;
        width: 12px;
        height: 12px;
        background: rgba(255,255,255,0.9);
        border-radius: 2px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.6);
        z-index: 20;
        display: none; /* hidden by default, shown only for selected */
      }
      /* Show resizers only for the selected element */
      .text-element.selected .resizer { display: block; }

      /* When canvas is in single-select mode, hide decorations (border/background/resizers) for other elements
         but keep their inner text visible. The wrapper (.text-element) will become visually transparent while
         .text-content remains shown. This preserves readability while focusing edit UI on the selected element. */
      .editor-canvas.single-select .text-element {
        /* Keep position and text, but remove visual chrome */
        background: transparent !important;
        border-color: transparent !important;
        box-shadow: none !important;
        /* keep text visible and selectable if needed */
        color: inherit;
        pointer-events: none; /* prevent interaction with non-selected wrappers */
      }
      /* Allow the inner text content to remain interactive/visible even when wrapper blocks pointer events */
      .editor-canvas.single-select .text-element .text-content {
        pointer-events: auto;
        opacity: 1;
        user-select: text;
      }
      /* Ensure selected element still shows chrome and handles */
      .editor-canvas.single-select .text-element.selected {
        pointer-events: auto;
        border-color: #a8e063 !important;
        background: rgba(168, 224, 99, 0.1) !important;
      }
      /* Hide resizers on non-selected elements explicitly */
      .editor-canvas.single-select .text-element .resizer { display: none !important; }
      .editor-canvas.single-select .text-element.selected .resizer { display: block !important; }
      .text-element .resizer.handle-nw { left: -8px; top: -8px; cursor: nwse-resize; }
      .text-element .resizer.handle-ne { right: -8px; top: -8px; cursor: nesw-resize; }
      .text-element .resizer.handle-se { right: -8px; bottom: -8px; cursor: nwse-resize; }
      .text-element .resizer.handle-sw { left: -8px; bottom: -8px; cursor: nesw-resize; }
      .text-element .resizer.handle-n  { left: 50%; top: -8px; transform: translateX(-50%); cursor: ns-resize; }
      .text-element .resizer.handle-s  { left: 50%; bottom: -8px; transform: translateX(-50%); cursor: ns-resize; }
      .text-element .resizer.handle-e  { right: -8px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }
      .text-element .resizer.handle-w  { left: -8px; top: 50%; transform: translateY(-50%); cursor: ew-resize; }

      .editor-toolbar {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }

      /* ensure inner text-content wraps and can be measured for auto-fit */
      .text-element .text-content {
        display: inline-block;
        white-space: pre-wrap;
        word-break: break-word;
        max-width: 100%;
        box-sizing: border-box;
      }

      .toolbar-group {
        display: flex;
        gap: 5px;
        align-items: center;
        background: #2a2a3e;
        padding: 8px;
        border-radius: 6px;
      }

      .toolbar-label {
        color: #aaa;
        font-size: 12px;
        margin-right: 5px;
      }

      .toolbar-input {
        padding: 5px 10px;
        background: #1a1a2e;
        color: white;
        border: 1px solid #444;
        border-radius: 4px;
        width: 80px;
      }

      .toolbar-btn {
        padding: 6px 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      /* brief flash to indicate save triggered */
      .flash-save {
        animation: flashSave 300ms ease-in-out;
        box-shadow: 0 0 8px rgba(102,126,234,0.8) !important;
      }
      @keyframes flashSave {
        0% { transform: translateY(0); }
        50% { transform: translateY(-2px) scale(1.02); }
        100% { transform: translateY(0); }
      }

      .toolbar-btn:hover {
        background: linear-gradient(135deg, #7a8ef5 0%, #8659b3 100%);
      }
    </style>
  </head>
  <body>
    <h2 style="margin-top:0; font-size:28px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">Control & Preview</h2>
    <div id="song-title" style="font-size:18px; font-weight:bold; margin-bottom:16px; color:#a8e063;"></div>
    
    <div class="btn-group">
      <button onclick="prevSlide()" class="btn btn-primary">
        ‚¨Ö Previous <span class="shortcut"></span>
      </button>
      <button onclick="nextSlide()" class="btn btn-primary">
        Next ‚û° / Space<span class="shortcut"></span>
      </button>
      <button id="projector-toggle" onclick="toggleProjector()" class="btn btn-success">
        üì∫ Open Projector <span class="shortcut">Alt+X</span>
      </button>
      <button id="projector-hide" onclick="toggleHideProjector()" class="btn btn-hide" style="display:none;">
        üëÅÔ∏è Show Projector <span class="shortcut">Alt+U</span>
      </button>
    </div>

    <div class="btn-group">
      <button onclick="decreaseFontSize()" class="btn btn-warning" title="Arrow Down">
        üî§‚ûñ Decrease Font Size (‚Üì)
      </button>
      <button onclick="resetFontSize()" class="btn btn-info" title="Ctrl+0">
        üî§‚Üª Reset Font Size (Ctrl+0)
      </button>
      <button onclick="increaseFontSize()" class="btn btn-warning" title="Arrow Up">
        üî§‚ûï Increase Font Size (‚Üë)
      </button>
    </div>

    <div id="image-zoom-controls" class="btn-group" style="display:none;">
      <button onclick="zoomOutImage()" class="btn btn-warning" title="Zoom Out Image">
        üîç‚ûñ Zoom Out
      </button>
      <button onclick="resetImageZoom()" class="btn btn-info" title="Reset Image Zoom">
        üîç‚Üª Reset Zoom
      </button>
      <button onclick="zoomInImage()" class="btn btn-warning" title="Zoom In Image">
        üîç‚ûï Zoom In
      </button>
    </div>

    <div style="display:flex; gap:10px;">
      <div class="select-wrapper" style="flex:1;">
        <label style="font-size:15px; font-weight:500;">üé® Service Background:</label>
        <select id="service-background-select" onchange="changeServiceBackground()">
          <option value="">No Background</option>
        </select>
      </div>

      <div class="select-wrapper" style="flex:1;">
        <label style="font-size:15px; font-weight:500;">üé® Hymnal Background:</label>
        <select id="background-select" onchange="changeBackground()">
          <option value="">No Background</option>
        </select>
      </div>
    </div>

    <div class="select-wrapper">
      <label style="font-size:15px; font-weight:500;">üìñ Bible Verse Background:</label>
      <select id="bible-background-select" onchange="changeBibleBackground()">
        <option value="">No Background</option>
      </select>
    </div>

    <div class="select-wrapper">
      <label style="font-size:15px; font-weight:500;">üî§ Display Font:</label>
      <select id="font-select" onchange="changeFont()">
        <option value="">Loading fonts...</option>
      </select>
    </div>


    <div id="slide-info" style="font-size:14px; margin-bottom:12px; color:#a0a0a0; font-weight:500; display:flex; align-items:center; gap:12px;">
      <span id="slide-counter"></span>
      <div id="slide-dots" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
    </div>

    <div id="slide-thumbnails" class="slide-thumbnails"></div>

    <script>
      const { ipcRenderer } = require('electron');
      let currentSlides = [];
      let currentIndex = 0;
      let currentSongName = '';
      let projectorOpen = false;
      let projectorHidden = false;
      let isServiceSlide = false; // Track if current slide is a service slide
      let isBibleVerse = false; // Track if current slide is a Bible verse

      // Load background images for all selectors
      async function loadBackgrounds() {
        const backgrounds = await ipcRenderer.invoke('get-backgrounds');
        
        // Populate hymnal background selector
        const hymnalSelect = document.getElementById('background-select');
        backgrounds.forEach(bg => {
          const option = document.createElement('option');
          option.value = bg;
          option.textContent = bg;
          hymnalSelect.appendChild(option);
        });
        
        // Populate service background selector
        const serviceSelect = document.getElementById('service-background-select');
        backgrounds.forEach(bg => {
          const option = document.createElement('option');
          option.value = bg;
          option.textContent = bg;
          serviceSelect.appendChild(option);
        });
        
        // Populate Bible verse background selector
        const bibleSelect = document.getElementById('bible-background-select');
        backgrounds.forEach(bg => {
          const option = document.createElement('option');
          option.value = bg;
          option.textContent = bg;
          bibleSelect.appendChild(option);
        });
        
        // Restore saved background selections from localStorage
        const savedHymnalBg = localStorage.getItem('hymnal-background');
        const savedServiceBg = localStorage.getItem('service-background');
        const savedBibleBg = localStorage.getItem('bible-background');
        
        if (savedHymnalBg) {
          hymnalSelect.value = savedHymnalBg;
        }
        if (savedServiceBg) {
          serviceSelect.value = savedServiceBg;
        }
        if (savedBibleBg) {
          bibleSelect.value = savedBibleBg;
        }
        // Apply selected background to editor canvas so user can preview placement
        const editorCanvasEl = document.getElementById('editorCanvas');
        const applyBg = async (filename) => {
          if (!filename) {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
            return;
          }
          const abs = await ipcRenderer.invoke('get-background-path', filename);
          if (abs) {
            // Use file:// path for CSS
            editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            editorCanvasEl.style.backgroundSize = 'cover';
            editorCanvasEl.style.backgroundPosition = 'center';
            editorCanvasEl.style.backgroundColor = '';
          }
        };
        // Apply hymnal/service/bible saved selection depending on which is active
        // Default to hymnal background if none selected for service
        const initialBg = savedServiceBg || savedHymnalBg || savedBibleBg || '';
        if (initialBg) applyBg(initialBg);
      }

      // Load system fonts
      async function loadFonts() {
        const fonts = await ipcRenderer.invoke('get-system-fonts');
        const fontSelect = document.getElementById('font-select');
        
        // Clear loading option
        fontSelect.innerHTML = '';
        
        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = 'Arial';
        defaultOption.textContent = 'Arial (Default)';
        fontSelect.appendChild(defaultOption);
        
        // Populate font selector
        fonts.forEach(font => {
          if (font !== 'Arial') { // Skip Arial since we already added it as default
            const option = document.createElement('option');
            option.value = font;
            option.textContent = font;
            // Apply the font to the option itself for preview
            option.style.fontFamily = font;
            fontSelect.appendChild(option);
          }
        });
        
        // Restore saved font selection from localStorage
        const savedFont = localStorage.getItem('display-font');
        if (savedFont) {
          fontSelect.value = savedFont;
          // Apply saved font immediately
          ipcRenderer.send('set-font', savedFont);
        } else {
          // Set default font
          ipcRenderer.send('set-font', 'Arial');
        }
      }

      // Change font
      async function changeFont() {
        const select = document.getElementById('font-select');
        const fontFamily = select.value;
        
        console.log('=== FONT CHANGE ===');
        console.log('Selected font:', fontFamily);
        
        // Save selection to localStorage
        localStorage.setItem('display-font', fontFamily);
        console.log('Saved to localStorage');
        
        // Send to projector window
        ipcRenderer.send('set-font', fontFamily);
        console.log('Sent set-font to main process');
        
        // Wait a moment for the font to be applied
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // If there's a current slide, re-show it with new font
        if (currentSlides.length > 0) {
          console.log('Re-displaying current slide with new font');
          showSlide();
        }
        
        // Visual feedback
        select.style.backgroundColor = '#2ecc71';
        setTimeout(() => {
          select.style.backgroundColor = '#2a2a3e';
        }, 300);
        
        console.log('===================');
      }

      // Change hymnal background
      function changeBackground() {
        const select = document.getElementById('background-select');
        const filename = select.value;
        
        // Save selection to localStorage
        localStorage.setItem('hymnal-background', filename);
        
        // Only apply if currently showing a hymnal slide
        if (!isServiceSlide && !isBibleVerse && currentSlides.length > 0) {
          ipcRenderer.send('set-background', filename);
          // Also apply to editor canvas for preview
          const editorCanvasEl = document.getElementById('editorCanvas');
          if (filename) {
            ipcRenderer.invoke('get-background-path', filename).then(abs => {
              if (abs) editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            });
          } else {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
          }
        }
        // Otherwise just store the selection for later use
      }

      // Change service background
      function changeServiceBackground() {
        const select = document.getElementById('service-background-select');
        const filename = select.value;
        
        // Save selection to localStorage
        localStorage.setItem('service-background', filename);
        
        // Only apply if currently showing a service slide
        if (isServiceSlide && currentSlides.length > 0) {
          ipcRenderer.send('set-background', filename);
          // Apply to editor canvas for preview
          const editorCanvasEl = document.getElementById('editorCanvas');
          if (filename) {
            ipcRenderer.invoke('get-background-path', filename).then(abs => {
              if (abs) editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            });
          } else {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
          }
        }
        // Otherwise just store the selection for later use
      }

      // Change Bible verse background
      function changeBibleBackground() {
        const select = document.getElementById('bible-background-select');
        const filename = select.value;
        
        // Save selection to localStorage
        localStorage.setItem('bible-background', filename);
        
        // Only apply if currently showing a Bible verse
        if (isBibleVerse && currentSlides.length > 0) {
          ipcRenderer.send('set-background', filename);
          // Apply to editor canvas for preview
          const editorCanvasEl = document.getElementById('editorCanvas');
          if (filename) {
            ipcRenderer.invoke('get-background-path', filename).then(abs => {
              if (abs) editorCanvasEl.style.backgroundImage = `url("file:///${abs.replace(/\\/g, '/')}")`;
            });
          } else {
            editorCanvasEl.style.backgroundImage = '';
            editorCanvasEl.style.backgroundColor = '#000';
          }
        }
        // Otherwise just store the selection for later use
      }

      // Listen for song loaded from list window
      ipcRenderer.on('song-loaded', (_, data) => {
        console.log('Song loaded:', data.name, 'Slides:', data.slides.length);
        currentSlides = data.slides;
        currentSongName = data.name;
        currentIndex = 0;
        
        // Detect if this is a service slide, Bible verse, or visual slide
        isServiceSlide = data.name.startsWith('Service:') || 
                        data.name.startsWith('Title:') || 
                        data.name === 'Visual Slide' ||
                        (data.slides.length > 0 && data.slides[0].type === 'visual');
        isBibleVerse = data.name.startsWith('Bible:');
        
        
        if (currentSlides.length > 0) {
          // Apply appropriate background when song loads
          if (isBibleVerse) {
            const select = document.getElementById('bible-background-select');
            const filename = select.value;
            if (filename) {
              ipcRenderer.send('set-background', filename);
            } else {
              // No Bible background selected, clear background
              ipcRenderer.send('set-background', '');
            }
          } else if (isServiceSlide) {
            const select = document.getElementById('service-background-select');
            const filename = select.value;
            if (filename) {
              ipcRenderer.send('set-background', filename);
            } else {
              // No service background selected, clear background
              ipcRenderer.send('set-background', '');
            }
          } else {
            const select = document.getElementById('background-select');
            const filename = select.value;
            if (filename) {
              ipcRenderer.send('set-background', filename);
            } else {
              // No hymnal background selected, use first available or clear
              ipcRenderer.send('set-background', '');
            }
          }
          createSlideDots();
          showSlide();
        }
      });

      function createSlideDots() {
        const dotsContainer = document.getElementById('slide-dots');
        dotsContainer.innerHTML = '';
        
        for (let i = 0; i < currentSlides.length; i++) {
          const dot = document.createElement('div');
          dot.className = 'slide-dot';
          dot.textContent = i + 1;
          dot.title = `Jump to slide ${i + 1}`;
          dot.onclick = () => jumpToSlide(i);
          dotsContainer.appendChild(dot);
        }
        
        // Create slide thumbnails
        createSlideThumbnails();
      }

      function createSlideThumbnails() {
        const thumbnailsContainer = document.getElementById('slide-thumbnails');
        thumbnailsContainer.innerHTML = '';
        
        for (let i = 0; i < currentSlides.length; i++) {
          const thumbnail = document.createElement('div');
          thumbnail.className = 'slide-thumbnail';
          if (i === currentIndex) {
            thumbnail.classList.add('active');
          }
          const number = document.createElement('div');
          number.className = 'slide-thumbnail-number';
          number.textContent = i + 1;
          const content = document.createElement('div');
          content.className = 'slide-thumbnail-content';
          const slideData = currentSlides[i];
          if (typeof slideData === 'object' && slideData.type === 'image') {
            // Display image thumbnail
            const img = document.createElement('img');
            img.src = `file:///${slideData.path.replace(/\\/g, '/')}`;
            img.style.cssText = 'max-width: 100%; max-height: 120px; object-fit: contain; border-radius: 4px;';
            content.appendChild(img);
          } else if (typeof slideData === 'object' && slideData.type === 'visual') {
            // Display canvas thumbnail for visual slide
            const canvas = document.createElement('canvas');
            // Larger drawing surface for clearer thumbnails
            canvas.width = 480; // high-res drawing surface
            canvas.height = 300;
            // Display size (CSS) - keep aspect ratio
            canvas.style.width = '240px';
            canvas.style.height = '150px';
            canvas.style.borderRadius = '6px';
            canvas.style.background = '#222';
            canvas.style.boxShadow = '0 1px 6px #0004';
            // Create an inner wrapper with fixed width so canvas and label stay centered
            const thumbInner = document.createElement('div');
            thumbInner.style.width = '240px';
            thumbInner.style.display = 'flex';
            thumbInner.style.flexDirection = 'column';
            thumbInner.style.alignItems = 'center';
            thumbInner.style.justifyContent = 'center';
            thumbInner.style.margin = '0 auto';
            thumbInner.appendChild(canvas);
            // Center the thumbnail block itself vertically/horizontally
            thumbnail.style.display = 'flex';
            thumbnail.style.flexDirection = 'column';
            thumbnail.style.alignItems = 'center';
            thumbnail.style.justifyContent = 'center';
            // Reduce extra top padding for visual thumbnails so canvas truly centers
            thumbnail.style.paddingTop = '15px';
            thumbnail.style.paddingBottom = '15px';
            // Center the canvas inside the thumbnail
            canvas.style.display = 'block';
            canvas.style.margin = '0 auto';
            // Use flex centering on content to be extra-safe
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.alignItems = 'center';
            content.style.justifyContent = 'center';
            content.style.gap = '8px';
            // Add a short preview label under the canvas
            const previewLabel = document.createElement('div');
            previewLabel.style.color = '#ccc';
            previewLabel.style.fontSize = '12px';
            previewLabel.style.textAlign = 'center';
            previewLabel.style.marginTop = '6px';
            previewLabel.style.width = '100%';
            let previewText = 'Visual Slide';
            if (slideData.elements && slideData.elements.length > 0 && slideData.elements[0].text) {
              previewText = slideData.elements[0].text.substring(0, 60);
              if (slideData.elements[0].text.length > 60) previewText += '...';
            }
            previewLabel.textContent = previewText;
            thumbInner.appendChild(previewLabel);
            // Center absolutely within the thumbnail container
            thumbInner.style.position = 'absolute';
            thumbInner.style.left = '50%';
            thumbInner.style.top = '50%';
            thumbInner.style.transform = 'translate(-50%, -50%)';
            // Ensure thumbnail is positioned (it already is via CSS) and append inner wrapper directly
            thumbnail.appendChild(thumbInner);
            // Draw elements
            setTimeout(() => {
              const ctx = canvas.getContext('2d');
              // Clear high-res canvas
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              let drawn = false;
              // Scale helper: map element positions from editor space to thumbnail
              const thumbW = canvas.width;
              const thumbH = canvas.height;
              // Use the real editor canvas size (fall back to 1000x600 if not available)
              const editorCanvasEl = document.getElementById('editorCanvas');
              const srcW = (editorCanvasEl && editorCanvasEl.clientWidth) ? editorCanvasEl.clientWidth : 1000;
              const srcH = (editorCanvasEl && editorCanvasEl.clientHeight) ? editorCanvasEl.clientHeight : 600;
              const scaleX = thumbW / srcW;
              const scaleY = thumbH / srcH;
              if (slideData.elements && slideData.elements.length > 0) {
                slideData.elements.forEach(el => {
                  if (el.type === 'rect') {
                    drawn = true;
                    ctx.fillStyle = el.color || '#4caf50';
                    const x = Math.max(0, Math.min(thumbW-10, (el.x || 10) * scaleX));
                    const y = Math.max(0, Math.min(thumbH-10, (el.y || 10) * scaleY));
                    const w = Math.max(10, Math.min(thumbW, (el.width || 200) * scaleX));
                    const h = Math.max(10, Math.min(thumbH, (el.height || 100) * scaleY));
                    ctx.fillRect(x, y, w, h);
                  } else if (el.type === 'text' && el.text) {
                    drawn = true;
                    // Font size scaled to thumbnail
                    const fontSize = Math.max(12, Math.floor((el.fontSize || 48) * Math.min(scaleX, scaleY)));
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.fillStyle = el.color || '#fff';
                    ctx.textBaseline = 'top';
                    // Estimate element box width if not provided
                    const estElemWidth = el.width || Math.min(srcW - (el.x || 0), (el.text.length * (el.fontSize || 48) * 0.6));
                    const scaledElemWidth = Math.max(20, estElemWidth * scaleX);
                    // Compute x based on alignment
                    let drawX = (el.x || 10) * scaleX;
                    let align = (el.align || 'left').toLowerCase();
                    if (align === 'center') {
                      ctx.textAlign = 'center';
                      drawX = drawX + scaledElemWidth / 2;
                    } else if (align === 'right') {
                      ctx.textAlign = 'right';
                      drawX = drawX + scaledElemWidth - 4;
                    } else {
                      ctx.textAlign = 'left';
                      drawX = drawX + 4;
                    }
                    const drawY = Math.max(4, Math.min(thumbH - 20, (el.y || 10) * scaleY));
                    // Truncate text to avoid overflow
                    let txt = el.text;
                    // Measure and trim to fit scaledElemWidth
                    if (ctx.measureText(txt).width > scaledElemWidth) {
                      while (txt.length > 0 && ctx.measureText(txt + '...').width > scaledElemWidth) {
                        txt = txt.slice(0, -1);
                      }
                      txt = txt + '...';
                    }
                    ctx.fillText(txt, drawX, drawY);
                    // reset textAlign to default for other elements
                    ctx.textAlign = 'start';
                  }
                });
              }
              if (!drawn) {
                ctx.font = 'bold 28px Arial';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('No Preview', thumbW/2, thumbH/2);
              }
            }, 0);
          } else {
            // Display text slide
            const slideText = typeof slideData === 'object' ? slideData.content : slideData;
            content.textContent = slideText;
          }
          thumbnail.appendChild(number);
          thumbnail.appendChild(content);
          thumbnail.onclick = () => jumpToSlide(i);
          thumbnailsContainer.appendChild(thumbnail);
        }
      }

      function jumpToSlide(index) {
        if (index >= 0 && index < currentSlides.length) {
          currentIndex = index;
          showSlide();
        }
      }

      function updateSlideDots() {
        const dots = document.querySelectorAll('.slide-dot');
        dots.forEach((dot, index) => {
          if (index === currentIndex) {
            dot.classList.add('active');
          } else {
            dot.classList.remove('active');
          }
        });
        
        // Also update thumbnails
        const thumbnails = document.querySelectorAll('.slide-thumbnail');
        thumbnails.forEach((thumbnail, index) => {
          if (index === currentIndex) {
            thumbnail.classList.add('active');
            // Scroll to active thumbnail
            thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          } else {
            thumbnail.classList.remove('active');
          }
        });
      }

      function showSlide() {
        if (currentSlides.length === 0) {
          console.log('No slides to show');
          return;
        }
        const slideData = currentSlides[currentIndex];
        
        console.log('Showing slide', currentIndex + 1, 'of', currentSlides.length);
        
        // Update UI
        document.getElementById('song-title').textContent = currentSongName;
        document.getElementById('slide-counter').textContent = `Slide ${currentIndex + 1} / ${currentSlides.length}`;
        
        // Update slide dots and thumbnails
        updateSlideDots();
        
        // If the visual editor is open, load the clicked slide into the editor
        const editorModal = document.getElementById('visualEditorModal');
        const isEditorOpen = editorModal && editorModal.style.display === 'block';
        if (isEditorOpen) {
          // Load the slide into the editor so user can edit the clicked slide
          editingVisualSlideIndex = currentIndex;
          editingVisualSlide = slideData;
          // Clear current editor state and render new slide data
          editorElements = [];
          selectedElement = null;
          clearCanvas();
          // If slide is visual, load directly; otherwise set editingVisualSlide and call loader
          loadExistingVisualSlide();
        }

        // Check slide type
        if (typeof slideData === 'object' && slideData.type === 'visual') {
          // Send visual slide with elements
          const payload = { 
            type: 'visual', 
            elements: slideData.elements,
            slideIndex: currentIndex, 
            totalSlides: currentSlides.length 
          };
          console.log('Control sending visual slide to projector:', payload);
          ipcRenderer.send('show-slide', payload);
        } else if (typeof slideData === 'object' && slideData.type === 'image') {
          // Send image path to projector
          const payload = { 
            type: 'image', 
            path: slideData.path,
            slideIndex: currentIndex, 
            totalSlides: currentSlides.length 
          };
          console.log('Control sending image to projector:', payload);
          ipcRenderer.send('show-slide', payload);
        } else {
          // Send text slide
          const text = typeof slideData === 'object' ? slideData.content : slideData;
          const payload = { 
            type: 'text',
            text, 
            slideIndex: currentIndex, 
            totalSlides: currentSlides.length 
          };
          console.log('Control sending text to projector:', text.substring(0, 50));
          ipcRenderer.send('show-slide', payload);
        }
      }

      function nextSlide() {
        console.log('Next clicked, current:', currentIndex, 'total:', currentSlides.length);
        if (currentIndex < currentSlides.length - 1) {
          currentIndex++;
          showSlide();
        } else {
          console.log('Already at last slide');
        }
      }

      function prevSlide() {
        console.log('Previous clicked, current:', currentIndex);
        if (currentIndex > 0) {
          currentIndex--;
          showSlide();
        } else {
          console.log('Already at first slide');
        }
      }

      function clearScreen() {
        console.log('clearScreen called');
        const preview = document.getElementById('preview');
        preview.innerHTML = `
          <div id="preview-overlay" style="position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); border-radius:10px;"></div>
          <div style="color:#666; position:relative; z-index:1;">Screen Cleared</div>
        `;
        currentSlideIndex = -1; // Reset slide index
        ipcRenderer.send('show-slide', '');
        console.log('Clear message sent to projector');
      }

      function toggleProjector() {
        console.log('Toggle projector - current state:', projectorOpen);
        if (projectorOpen) {
          console.log('Closing projector...');
          ipcRenderer.send('close-projector');
        } else {
          console.log('Opening projector...');
          ipcRenderer.send('open-projector');
        }
      }

      function updateProjectorButton(isOpen) {
        console.log('Updating projector button state to:', isOpen);
        projectorOpen = isOpen;
        const button = document.getElementById('projector-toggle');
        const hideButton = document.getElementById('projector-hide');
        
        if (isOpen) {
          button.innerHTML = '‚ùå Close Projector <span class="shortcut">Alt+X</span>';
          button.className = 'btn btn-warning';
          hideButton.style.display = 'inline-flex';
          updateHideButton(false); // Reset hide state when opening
        } else {
          button.innerHTML = 'üì∫ Open Projector <span class="shortcut">Alt+X</span>';
          button.className = 'btn btn-success';
          hideButton.style.display = 'none';
          projectorHidden = false;
        }
      }

      function toggleHideProjector() {
        if (projectorHidden) {
          ipcRenderer.send('show-projector');
        } else {
          ipcRenderer.send('hide-projector');
        }
      }

      function updateHideButton(isHidden) {
        projectorHidden = isHidden;
        const hideButton = document.getElementById('projector-hide');
        if (isHidden) {
          hideButton.innerHTML = 'üëÅÔ∏è Show Projector <span class="shortcut">Alt+U</span>';
          hideButton.className = 'btn btn-secondary';
        } else {
          hideButton.innerHTML = 'üôà Hide Projector <span class="shortcut">Alt+U</span>';
          hideButton.className = 'btn btn-hide';
        }
      }

      // Font size control functions - when editor is open, operate on editor elements
      function increaseFontSize() {
        const editorModal = document.getElementById('visualEditorModal');
        const fontInput = document.getElementById('fontSize');
        if (editorModal && editorModal.style.display === 'block' && fontInput) {
          let val = parseInt(fontInput.value) || 48;
          val = Math.min(300, val + 2);
          fontInput.value = val;
          updateSelectedElement();
          return;
        }
        ipcRenderer.send('adjust-font-size', 'increase');
      }

      function decreaseFontSize() {
        const editorModal = document.getElementById('visualEditorModal');
        const fontInput = document.getElementById('fontSize');
        if (editorModal && editorModal.style.display === 'block' && fontInput) {
          let val = parseInt(fontInput.value) || 48;
          val = Math.max(8, val - 2);
          fontInput.value = val;
          updateSelectedElement();
          return;
        }
        ipcRenderer.send('adjust-font-size', 'decrease');
      }

      function resetFontSize() {
        const editorModal = document.getElementById('visualEditorModal');
        const fontInput = document.getElementById('fontSize');
        if (editorModal && editorModal.style.display === 'block' && fontInput) {
          const val = 48;
          fontInput.value = val;
          updateSelectedElement();
          return;
        }
        ipcRenderer.send('adjust-font-size', 'reset');
      }

      // Keyboard shortcuts for font size control
      document.addEventListener('keydown', (event) => {
        // Arrow Up = Increase font size
        if (event.key === 'ArrowUp') {
          event.preventDefault();
          increaseFontSize();
        }
        // Arrow Down = Decrease font size
        else if (event.key === 'ArrowDown') {
          event.preventDefault();
          decreaseFontSize();
        }
        // Ctrl+0 = Reset font size
        else if (event.ctrlKey && event.key === '0') {
          event.preventDefault();
          resetFontSize();
        }
      });

      // Image zoom control functions
      function zoomInImage() {
        ipcRenderer.send('adjust-image-zoom', 'in');
      }

      function zoomOutImage() {
        ipcRenderer.send('adjust-image-zoom', 'out');
      }

      function resetImageZoom() {
        ipcRenderer.send('adjust-image-zoom', 'reset');
      }

      // Listen for projector state changes
      ipcRenderer.on('projector-state', (event, isOpen) => {
        updateProjectorButton(isOpen);
      });

      ipcRenderer.on('projector-visibility', (event, isHidden) => {
        updateHideButton(isHidden);
      });

      // Listen for image display state
      ipcRenderer.on('image-displayed', (event, isImage) => {
        const zoomControls = document.getElementById('image-zoom-controls');
        if (zoomControls) {
          zoomControls.style.display = isImage ? 'flex' : 'none';
        }
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Check if visual editor is open
        const editorModal = document.getElementById('visualEditorModal');
        const isEditorOpen = editorModal && editorModal.style.display === 'block';
        
        // If visual editor is open and user is editing text (including inner .text-content), allow normal spacebar behavior
        if (isEditorOpen) {
          const activeElement = document.activeElement;
          try {
            if (activeElement && activeElement.closest && activeElement.closest('.text-element')) {
              // User is editing text in visual editor, allow spacebar
              return;
            }
          } catch (err) {}
        }
        
        if (e.key === 'ArrowRight' || e.key === ' ') {
          e.preventDefault();
          nextSlide();
        }
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          prevSlide();
        }
        if (e.altKey && e.key.toLowerCase() === 'x') {
          e.preventDefault();
          toggleProjector();
        }
        if (e.altKey && e.key.toLowerCase() === 'u') {
          e.preventDefault();
          toggleHideProjector();
        }
      });

      // Visual Editor Variables
      let editorElements = [];
      let selectedElement = null;
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let elementIdCounter = 0;
      let currentEditingService = null;
      let editingVisualSlideIndex = -1;
      let editingVisualSlide = null;
      
      // Undo/Redo functionality
      let undoStack = [];
      let redoStack = [];
      
      // Save current state for undo
      function saveStateForUndo() {
        // Create a deep copy of current state
        const state = {
          elements: editorElements.map(el => ({...el})),
          elementIdCounter: elementIdCounter
        };
        undoStack.push(state);
        // Limit undo stack to 50 actions
        if (undoStack.length > 50) {
          undoStack.shift();
        }
        // Clear redo stack when new action is performed
        redoStack = [];
        console.log('State saved for undo. Stack size:', undoStack.length);
      }
      
      // Undo last action
      function undo() {
        if (undoStack.length === 0) {
          console.log('Nothing to undo');
          return;
        }
        
        // Save current state to redo stack
        const currentState = {
          elements: editorElements.map(el => ({...el})),
          elementIdCounter: elementIdCounter
        };
        redoStack.push(currentState);
        
        // Restore previous state
        const previousState = undoStack.pop();
        restoreState(previousState);
        console.log('Undo performed. Undo stack:', undoStack.length, 'Redo stack:', redoStack.length);
      }
      
      // Redo last undone action
      function redo() {
        if (redoStack.length === 0) {
          console.log('Nothing to redo');
          return;
        }
        
        // Save current state to undo stack
        const currentState = {
          elements: editorElements.map(el => ({...el})),
          elementIdCounter: elementIdCounter
        };
        undoStack.push(currentState);
        
        // Restore next state
        const nextState = redoStack.pop();
        restoreState(nextState);
        console.log('Redo performed. Undo stack:', undoStack.length, 'Redo stack:', redoStack.length);
      }
      
      // Restore state from snapshot
      function restoreState(state) {
        // Clear current elements
        clearCanvas();
        
        // Restore element counter
        elementIdCounter = state.elementIdCounter;
        
        // Restore elements
        editorElements = state.elements.map(el => ({...el}));
        
        // Re-render all elements
        const canvas = document.getElementById('editorCanvas');
        editorElements.forEach(elemData => {
          const element = document.createElement('div');
          element.className = 'text-element';
          element.id = elemData.id;
          // inner editable content
          const contentDiv = document.createElement('div');
          contentDiv.className = 'text-content';
          contentDiv.contentEditable = true;
          contentDiv.innerText = elemData.text || '';
          element.appendChild(contentDiv);
          // elemData.x/y are percent, fontSize is vw
          const canvas = document.getElementById('editorCanvas');
          element.style.left = (elemData.x !== undefined ? elemData.x : 50) + '%';
          element.style.top = (elemData.y !== undefined ? elemData.y : 50) + '%';
          const fontPx = (elemData.fontSize !== undefined) ? ((elemData.fontSize / 100) * (canvas.clientWidth || 960)) : 48;
          element.style.fontSize = fontPx + 'px';
          element.style.color = elemData.color;
          element.style.textAlign = elemData.align;
          // Apply stored width/height if present (percent values)
          if (elemData.width !== undefined && elemData.width !== null) {
            element.style.width = elemData.width + '%';
          }
          if (elemData.height !== undefined && elemData.height !== null) {
            element.style.height = elemData.height + '%';
          }
          // Add event listeners
          element.addEventListener('mousedown', startDrag);
          element.addEventListener('click', selectElement);
          element.addEventListener('dblclick', enterEditMode);
          // contentDiv handles input/blur
          contentDiv.addEventListener('input', updateElementText);
          contentDiv.addEventListener('blur', finishEditing);

          // add resizer handles
          createResizers(element);
          // auto-fit default for restored elements (unless explicitly disabled)
          const elemDatum = editorElements.find(el => el.id === element.id);
          if (elemDatum && elemDatum.autoFit !== false) {
            // ensure box fits its content on restore
            setTimeout(() => autoFitElement(element), 0);
          }
          canvas.appendChild(element);
        });
        
        // Clear selection
        selectedElement = null;
      }

      // Listen for open visual editor message from list window
      ipcRenderer.on('open-visual-editor', (_, data) => {
        console.log('Received open-visual-editor message:', data);
        currentEditingService = data.service;
        
        // Check if we're editing an existing slide (any type)
        if (data.editingSlide) {
          console.log('Editing existing slide:', data.editingSlide);
          editingVisualSlideIndex = data.editingIndex;
          editingVisualSlide = data.editingSlide;
        } else {
          editingVisualSlideIndex = -1;
          editingVisualSlide = null;
        }
        
        openVisualEditor();
      });

      // Helper function to clear canvas while preserving snap guides
      function clearCanvas() {
        const canvas = document.getElementById('editorCanvas');
        const elements = canvas.querySelectorAll('.text-element');
        elements.forEach(el => el.remove());
        
        // Ensure snap guides exist
        let snapGuideH = document.getElementById('snapGuideHorizontal');
        let snapGuideV = document.getElementById('snapGuideVertical');
        
        if (!snapGuideH) {
          snapGuideH = document.createElement('div');
          snapGuideH.id = 'snapGuideHorizontal';
          snapGuideH.className = 'snap-guide horizontal';
          canvas.appendChild(snapGuideH);
        }
        
        if (!snapGuideV) {
          snapGuideV = document.createElement('div');
          snapGuideV.id = 'snapGuideVertical';
          snapGuideV.className = 'snap-guide vertical';
          canvas.appendChild(snapGuideV);
        }
      }

      // Open Visual Editor
      function openVisualEditor() {
        document.getElementById('visualEditorModal').style.display = 'block';
        
        // Clear previous content
        editorElements = [];
        selectedElement = null;
        clearCanvas();
        elementIdCounter = 0;
        
        // Clear undo/redo stacks
        undoStack = [];
        redoStack = [];
        
        // If editing existing slide (any type), load its content
        if (editingVisualSlide) {
          console.log('Loading existing slide elements:', editingVisualSlide);
          loadExistingVisualSlide();
        }
        // Initialize toolbar font size to default or to first element's fontSize
        const fontInput = document.getElementById('fontSize');
        if (fontInput) {
          let defaultSize = 48;
          if (editingVisualSlide && editingVisualSlide.elements && editingVisualSlide.elements.length > 0) {
            const first = editingVisualSlide.elements[0];
            if (first && first.fontSize) defaultSize = first.fontSize;
          }
          fontInput.value = defaultSize;
        }
        // Apply saved grid preference
        const gridOn = localStorage.getItem('editor-grid') === 'true';
        const canvas = document.getElementById('editorCanvas');
        if (gridOn) canvas.classList.add('grid-on'); else canvas.classList.remove('grid-on');
      }

      function toggleEditorGrid() {
        const canvas = document.getElementById('editorCanvas');
        if (!canvas) return;
        const isOn = canvas.classList.toggle('grid-on');
        localStorage.setItem('editor-grid', isOn ? 'true' : 'false');
        // update button appearance
        const btn = document.getElementById('toggle-grid-btn');
        if (btn) btn.style.backgroundColor = isOn ? '#2ecc71' : '';
      }

      // Close Visual Editor
      function closeVisualEditor() {
        document.getElementById('visualEditorModal').style.display = 'none';
        editorElements = [];
        selectedElement = null;
        clearCanvas();
        editingVisualSlideIndex = -1;
        editingVisualSlide = null;
        
        // Clear undo/redo stacks
        undoStack = [];
        redoStack = [];
      }

      // Add Text Element
      function addTextElement() {
        saveStateForUndo(); // Save state before adding element
        
        const canvas = document.getElementById('editorCanvas');
  const element = document.createElement('div');
  element.className = 'text-element';
  element.id = 'element-' + (elementIdCounter++);
  // inner editable content so resizer isn't removed when editing
  const contentDiv = document.createElement('div');
  contentDiv.className = 'text-content';
  contentDiv.contentEditable = true;
  contentDiv.innerText = 'New Text';
  element.appendChild(contentDiv);
        element.style.left = '50%';
        element.style.top = '50%';
        element.style.fontSize = '48px'; /* Initial px; will convert to vw on save */
        element.style.color = '#ffffff';
        element.style.textAlign = 'center'; /* Ensure center */
        element.contentEditable = true;
        
        // Add event listeners
        element.addEventListener('mousedown', startDrag);
        element.addEventListener('click', selectElement);
        element.addEventListener('dblclick', enterEditMode);
  // listen on contentDiv for edits
  contentDiv.addEventListener('input', updateElementText);
  contentDiv.addEventListener('blur', finishEditing);
        
  // Add resizer handles
  createResizers(element);

  canvas.appendChild(element);
  // Store as percent positions and vw fontSize
  const canvasW = canvas.clientWidth || 960;
  editorElements.push({ id: element.id, x: 50, y: 50, fontSize: (48 / canvasW * 100), text: contentDiv.innerText, color: '#ffffff', align: 'center', width: undefined, height: undefined, autoFit: true });
        selectElement({ target: element });
        
        selectElement({ target: element });
        // Start in editing mode for new elements
        element.classList.add('editing');
        element.focus(); // Focus for immediate editing
      }

      // Select Element
      function selectElement(e) {
        if (selectedElement) {
          selectedElement.classList.remove('selected');
        }
  // select the wrapper element even if event target is the inner content
  selectedElement = e.target.closest('.text-element');
        const canvas = document.getElementById('editorCanvas');
        // Enter single-select mode: hide others
        if (canvas) canvas.classList.add('single-select');
        if (selectedElement) {
          // ensure previously selected hidden and this one visible
          selectedElement.classList.add('selected');
          
          // Update toolbar with element properties
          document.getElementById('fontSize').value = parseInt(selectedElement.style.fontSize);
          document.getElementById('textColor').value = rgbToHex(selectedElement.style.color);
        }
      }

      // Clear single-selection and show all elements
      function clearSelection() {
        const canvas = document.getElementById('editorCanvas');
        if (canvas) canvas.classList.remove('single-select');
        if (selectedElement) {
          selectedElement.classList.remove('selected');
          selectedElement = null;
        }
      }

      // Clicking the canvas (not an element) clears single-select mode
      document.addEventListener('click', (e) => {
        const canvas = document.getElementById('editorCanvas');
        if (!canvas) return;
        if (e.target === canvas) {
          clearSelection();
        }
      });
      
      // Enter editing mode on double-click
      function enterEditMode(e) {
        const wrapper = e.target.closest('.text-element');
        if (wrapper) {
          wrapper.classList.add('editing');
          const content = wrapper.querySelector('.text-content');
          if (content) {
            content.focus();
            // Select all text for easy replacement
            const range = document.createRange();
            range.selectNodeContents(content);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          }
        }
      }
      
      // Exit editing mode
      function exitEditMode(element) {
        if (element && element.classList.contains('text-element')) {
          element.classList.remove('editing');
        }
      }

      // Start Drag (percent-based positions)
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartLeft = 50;
      let dragStartTop = 50;
    // pointer offset inside element when drag starts (px)
    let dragPointerOffsetX = 0;
    let dragPointerOffsetY = 0;
    let dragElementWidthPx = 0;
    let dragElementHeightPx = 0;
  let isResizing = false;
  let resizeStartX = 0;
  let resizeStartY = 0;
  let resizeStartWidth = 0;
  let resizeStartHeight = 0;
  let resizeTarget = null;
  const gridSizePx = 20; // snap grid size in pixels

      function startDrag(e) {
        // only left button and non-editing
        if (e.button !== 0) return;
        const wrapper = e.target.closest ? e.target.closest('.text-element') : null;
        if (!wrapper) return;
        if (wrapper.classList.contains('editing')) return;

        saveStateForUndo();

        selectedElement = wrapper;
        // normalize selectElement call
        selectElement({ target: wrapper });

  dragStartX = e.clientX;
  dragStartY = e.clientY;

  // compute pointer offset within the element (relative to element's top-left)
  const rect = wrapper.getBoundingClientRect();
  dragPointerOffsetX = e.clientX - rect.left;
  dragPointerOffsetY = e.clientY - rect.top;
  dragElementWidthPx = rect.width;
  dragElementHeightPx = rect.height;

        // parse percent left/top (fallback to 50)
        dragStartLeft = parseFloat(selectedElement.style.left) || 50;
        dragStartTop = parseFloat(selectedElement.style.top) || 50;

        document.addEventListener('mousemove', dragElement);
        document.addEventListener('mouseup', stopDrag);

        e.preventDefault();
      }

      // Start resizing when resizer handle mousedown
      function startResize(e) {
        // e is the mousedown event on a resizer handle; expect dataset.dir like 'se','n','w' etc.
        if (e.button !== 0) return;
        e.stopPropagation();
        e.preventDefault();
        const handle = e.target;
        const dir = handle && handle.dataset ? handle.dataset.dir : null;
        isResizing = true;
        resizeTarget = e.target.closest('.text-element');
        if (!resizeTarget) return;
  // Disable autoFit for this element when user manually resizes
  const elemDatum = editorElements.find(el => el.id === resizeTarget.id);
  if (elemDatum) elemDatum.autoFit = false;
        resizeTarget._resizeDir = dir || 'se';
        // ensure element is selected during resize to avoid blinking
        selectedElement = resizeTarget;
        selectedElement.classList.add('selected');
        saveStateForUndo();

        const rect = resizeTarget.getBoundingClientRect();
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        resizeStartWidth = rect.width;
        resizeStartHeight = rect.height;

        // During drag use px sizes to avoid percent rounding flicker; convert on mouseup
        document.addEventListener('mousemove', resizeElement);
        document.addEventListener('mouseup', stopResize);
      }

      // Create 8 resize handles on the element and attach direction metadata
      function createResizers(element) {
        const dirs = ['nw','n','ne','e','se','s','sw','w'];
        dirs.forEach(d => {
          const handle = document.createElement('div');
          handle.className = 'resizer handle-' + d;
          handle.dataset.dir = d;
          handle.addEventListener('mousedown', startResize);
          element.appendChild(handle);
        });
      }

      function dragElement(e) {
        if (!selectedElement) return;
        const canvasRect = document.getElementById('editorCanvas').getBoundingClientRect();

        // desired top-left (px) if pointer offset is applied
        let desiredLeftPx = e.clientX - dragPointerOffsetX;
        let desiredTopPx = e.clientY - dragPointerOffsetY;

        // If grid is active, snap the pointer position to the grid and compute top-left so pointer stays anchored
        const canvas = document.getElementById('editorCanvas');
        const gridOn = canvas && canvas.classList && canvas.classList.contains('grid-on');
        if (gridOn && typeof gridSizePx === 'number' && gridSizePx > 0) {
          const snappedPointerX = Math.round(e.clientX / gridSizePx) * gridSizePx;
          const snappedPointerY = Math.round(e.clientY / gridSizePx) * gridSizePx;
          desiredLeftPx = snappedPointerX - dragPointerOffsetX;
          desiredTopPx = snappedPointerY - dragPointerOffsetY;
        }

        // Keep element inside canvas bounds
        desiredLeftPx = Math.max(canvasRect.left - (dragElementWidthPx/2), Math.min(desiredLeftPx, canvasRect.right - (dragElementWidthPx/2) - 1));
        desiredTopPx = Math.max(canvasRect.top - (dragElementHeightPx/2), Math.min(desiredTopPx, canvasRect.bottom - (dragElementHeightPx/2) - 1));

        // Convert top-left px to center percent values
        const centerPxX = desiredLeftPx + (dragElementWidthPx / 2) - canvasRect.left;
        const centerPxY = desiredTopPx + (dragElementHeightPx / 2) - canvasRect.top;
        let newLeftPct = (centerPxX / canvasRect.width) * 100;
        let newTopPct = (centerPxY / canvasRect.height) * 100;

        // snap to center percent threshold
        const snapThreshold = 2; // percent
        if (Math.abs(newLeftPct - 50) < snapThreshold) newLeftPct = 50;
        if (Math.abs(newTopPct - 50) < snapThreshold) newTopPct = 50;

        const sgH = document.getElementById('snapGuideHorizontal');
        const sgV = document.getElementById('snapGuideVertical');
        if (sgH) sgH.classList.toggle('visible', Math.abs(newTopPct - 50) < snapThreshold);
        if (sgV) sgV.classList.toggle('visible', Math.abs(newLeftPct - 50) < snapThreshold);

        selectedElement.style.left = Math.max(0, Math.min(100, newLeftPct)) + '%';
        selectedElement.style.top = Math.max(0, Math.min(100, newTopPct)) + '%';

        // Update model
        const elemData = editorElements.find(el => el.id === selectedElement.id);
        if (elemData) {
          elemData.x = parseFloat(selectedElement.style.left) || newLeftPct;
          elemData.y = parseFloat(selectedElement.style.top) || newTopPct;
        }
      }

      // Resize handler (change width/height in percent relative to canvas)
      function resizeElement(e) {
        if (!isResizing || !resizeTarget) return;
        e.preventDefault();
        const canvas = document.getElementById('editorCanvas');
        const canvasRect = canvas.getBoundingClientRect();

        const dx = e.clientX - resizeStartX;
        const dy = e.clientY - resizeStartY;

        // Determine direction
        const dir = (resizeTarget && resizeTarget._resizeDir) ? resizeTarget._resizeDir : 'se';

        // Start from original px sizes
        let newWidthPx = resizeStartWidth;
        let newHeightPx = resizeStartHeight;
        let leftPx = resizeTarget.getBoundingClientRect().left;
        let topPx = resizeTarget.getBoundingClientRect().top;

        // Adjust based on direction. For side handles, only change one dimension; corners change both.
        if (dir.includes('e')) {
          newWidthPx = Math.max(20, resizeStartWidth + dx);
        }
        if (dir.includes('s')) {
          newHeightPx = Math.max(20, resizeStartHeight + dy);
        }
        if (dir.includes('w')) {
          newWidthPx = Math.max(20, resizeStartWidth - dx);
          // move left as width grows to the left
          leftPx = leftPx + dx;
        }
        if (dir.includes('n')) {
          newHeightPx = Math.max(20, resizeStartHeight - dy);
          topPx = topPx + dy;
        }

        // Apply px sizes temporarily
        resizeTarget.style.width = newWidthPx + 'px';
        resizeTarget.style.height = newHeightPx + 'px';

        // Update left/top if north or west affected (convert leftPx/topPx to percent relative to canvas)
        const canvasRect2 = canvas.getBoundingClientRect();
        if (dir.includes('w') || dir.includes('n')) {
          const newLeftPct = ((leftPx - canvasRect2.left) / canvasRect2.width) * 100;
          const newTopPct = ((topPx - canvasRect2.top) / canvasRect2.height) * 100;
          if (dir.includes('w')) resizeTarget.style.left = Math.max(0, Math.min(100, newLeftPct)) + '%';
          if (dir.includes('n')) resizeTarget.style.top = Math.max(0, Math.min(100, newTopPct)) + '%';
        }

        // Update model percent sizes for persistence
  // Snap size to grid
  newWidthPx = Math.round(newWidthPx / gridSizePx) * gridSizePx;
  newHeightPx = Math.round(newHeightPx / gridSizePx) * gridSizePx;

  const newWidthPct = (newWidthPx / canvasRect2.width) * 100;
  const newHeightPct = (newHeightPx / canvasRect2.height) * 100;
        const elemData = editorElements.find(el => el.id === resizeTarget.id);
        if (elemData) {
          elemData.width = Math.max(0.5, Math.min(100, newWidthPct));
          elemData.height = Math.max(0.5, Math.min(100, newHeightPct));
          if (dir.includes('w')) elemData.x = parseFloat(resizeTarget.style.left) || elemData.x;
          if (dir.includes('n')) elemData.y = parseFloat(resizeTarget.style.top) || elemData.y;
        }
      }

      function stopResize() {
        if (!isResizing) return;
        document.removeEventListener('mousemove', resizeElement);
        document.removeEventListener('mouseup', stopResize);

        // Convert px style to percent style for persistence/display consistency
        const canvas = document.getElementById('editorCanvas');
        const canvasRect = canvas.getBoundingClientRect();
        const rect = resizeTarget.getBoundingClientRect();
        const finalWidthPct = (rect.width / canvasRect.width) * 100;
        const finalHeightPct = (rect.height / canvasRect.height) * 100;
        // clamp
        const wPct = Math.max(0.5, Math.min(100, finalWidthPct));
        const hPct = Math.max(0.5, Math.min(100, finalHeightPct));
        resizeTarget.style.width = wPct + '%';
        resizeTarget.style.height = hPct + '%';

        // Update model (already partially updated during drag)
        const elemData = editorElements.find(el => el.id === resizeTarget.id);
        if (elemData) {
          elemData.width = wPct;
          elemData.height = hPct;
        }

        isResizing = false;
        // keep element selected, clear resizeTarget
        resizeTarget = null;
      }

      function stopDrag() {
        document.removeEventListener('mousemove', dragElement);
        document.removeEventListener('mouseup', stopDrag);
        // If we are resizing, keep the element selected to avoid flicker
        if (!isResizing) {
          // perform final snap-to-grid on mouseup to keep element aligned, but only if grid is enabled
          const canvas = document.getElementById('editorCanvas');
          const canvasRect = canvas.getBoundingClientRect();
          if (selectedElement) {
            const rect = selectedElement.getBoundingClientRect();
            // center px within canvas
            const centerPxX = rect.left - canvasRect.left + rect.width / 2;
            const centerPxY = rect.top - canvasRect.top + rect.height / 2;
            const snappedCenterX = Math.round(centerPxX / gridSizePx) * gridSizePx;
            const snappedCenterY = Math.round(centerPxY / gridSizePx) * gridSizePx;
            const snappedLeftPct = ((snappedCenterX) / canvasRect.width) * 100;
            const snappedTopPct = ((snappedCenterY) / canvasRect.height) * 100;
            // Apply snapped percent positions
            selectedElement.style.left = Math.max(0, Math.min(100, snappedLeftPct)) + '%';
            selectedElement.style.top = Math.max(0, Math.min(100, snappedTopPct)) + '%';
            // Update model
            const elemData = editorElements.find(el => el.id === selectedElement.id);
            if (elemData) {
              elemData.x = parseFloat(selectedElement.style.left) || elemData.x;
              elemData.y = parseFloat(selectedElement.style.top) || elemData.y;
            }
          }
          selectedElement = null;
        }

        const sgH = document.getElementById('snapGuideHorizontal');
        const sgV = document.getElementById('snapGuideVertical');
        if (sgH) sgH.classList.remove('visible');
        if (sgV) sgV.classList.remove('visible');
      }

      // Update element text when content changes
      function updateElementText(e) {
        // e.target is the inner .text-content
        const content = e.target;
        const wrapper = content.closest('.text-element');
        if (!wrapper) return;
        const elemData = editorElements.find(el => el.id === wrapper.id);
        if (elemData) {
          elemData.text = content.innerText;
          // If this element is in autoFit mode, adjust its box to fit new content
          if (elemData.autoFit !== false) {
            autoFitElement(wrapper);
          }
        }
      }

      // Finish editing when element loses focus
      function finishEditing(e) {
        const content = e.target;
        const wrapper = content.closest('.text-element');
        if (!wrapper) return;
        const elemData = editorElements.find(el => el.id === wrapper.id);
        if (elemData) {
          elemData.text = content.innerText;
        }
        // Exit editing mode
        exitEditMode(wrapper);
      }

      // Update Selected Element
      function updateSelectedElement() {
        if (selectedElement) {
          const fontSize = document.getElementById('fontSize').value;
          const textColor = document.getElementById('textColor').value;
          // Update font size and color, preserve visual center using percent coords
          const canvas = document.getElementById('editorCanvas');
          const canvasRect = canvas.getBoundingClientRect();

          // compute current center in pixels
          const beforeRect = selectedElement.getBoundingClientRect();
          const centerPxX = beforeRect.left - canvasRect.left + beforeRect.width / 2;
          const centerPxY = beforeRect.top - canvasRect.top + beforeRect.height / 2;

          // apply new font size
          const fontPx = parseFloat(fontSize) || 48;
          selectedElement.style.fontSize = fontPx + 'px';
          selectedElement.style.color = textColor;

          // compute new center and adjust left/top percent to keep same center
          const afterRect = selectedElement.getBoundingClientRect();
          const desiredCenterPctX = (centerPxX / canvasRect.width) * 100;
          const desiredCenterPctY = (centerPxY / canvasRect.height) * 100;

          selectedElement.style.left = desiredCenterPctX + '%';
          selectedElement.style.top = desiredCenterPctY + '%';
          
          // Update in elements array (store font size as vw)
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            const canvasW = canvas.clientWidth || 960;
            elemData.fontSize = (fontPx / canvasW * 100);
            elemData.color = textColor;
            elemData.x = parseFloat(selectedElement.style.left) || elemData.x;
            elemData.y = parseFloat(selectedElement.style.top) || elemData.y;
          }
        }
      }

        // Auto-fit an element's wrapper to match its inner text-content size (PowerPoint-like behavior)
        function autoFitElement(wrapper) {
          if (!wrapper) return;
          const content = wrapper.querySelector('.text-content');
          if (!content) return;

          const canvas = document.getElementById('editorCanvas');
          if (!canvas) return;
          const canvasRect = canvas.getBoundingClientRect();

          // Temporarily measure content by cloning into an offscreen element to get intrinsic size
          const measurer = document.createElement('div');
          measurer.style.position = 'absolute';
          measurer.style.visibility = 'hidden';
          measurer.style.whiteSpace = 'pre-wrap';
          measurer.style.font = window.getComputedStyle(content).font;
          measurer.style.lineHeight = window.getComputedStyle(content).lineHeight;
          measurer.style.width = 'auto';
          measurer.style.maxWidth = (canvasRect.width - 20) + 'px'; // keep some padding
          measurer.textContent = content.innerText || content.textContent || '';
          document.body.appendChild(measurer);

          const measuredW = Math.min(measurer.offsetWidth + 20, canvasRect.width); // padding
          const measuredH = Math.min(measurer.offsetHeight + 16, canvasRect.height);
          document.body.removeChild(measurer);

          // Preserve visual center: compute current center in px
          const beforeRect = wrapper.getBoundingClientRect();
          const centerPxX = beforeRect.left - canvasRect.left + beforeRect.width / 2;
          const centerPxY = beforeRect.top - canvasRect.top + beforeRect.height / 2;

          // Apply new width/height in px temporarily then convert to percent
          wrapper.style.width = measuredW + 'px';
          wrapper.style.height = measuredH + 'px';

          // compute new center to keep element centered where it was
          const afterRect = wrapper.getBoundingClientRect();
          const desiredCenterPctX = (centerPxX / canvasRect.width) * 100;
          const desiredCenterPctY = (centerPxY / canvasRect.height) * 100;
          wrapper.style.left = desiredCenterPctX + '%';
          wrapper.style.top = desiredCenterPctY + '%';

          // Convert width/height px to percent and update model
          const wPct = (measuredW / canvasRect.width) * 100;
          const hPct = (measuredH / canvasRect.height) * 100;
          wrapper.style.width = Math.max(1, Math.min(100, wPct)) + '%';
          wrapper.style.height = Math.max(1, Math.min(100, hPct)) + '%';

          const elemData = editorElements.find(el => el.id === wrapper.id);
          if (elemData) {
            elemData.width = Math.max(1, Math.min(100, wPct));
            elemData.height = Math.max(1, Math.min(100, hPct));
          }
        }

      // Align Text (inside the text box)
      function alignText(alignment) {
        if (selectedElement) {
          saveStateForUndo(); // Save state before aligning
          
          selectedElement.style.textAlign = alignment;
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.align = alignment;
          }
          console.log('Aligned text to:', alignment);
        }
      }
      
      // Align Text Box Horizontally (position on canvas)
      function alignBoxHorizontal(alignment) {
        if (selectedElement) {
          saveStateForUndo(); // Save state before aligning
          const canvas = document.getElementById('editorCanvas');
          const canvasRect = canvas.getBoundingClientRect();
          const canvasWidth = canvasRect.width;
          const boxWidth = selectedElement.offsetWidth;
          let newLeftPx;

          switch(alignment) {
            case 'left':
              newLeftPx = 0 + boxWidth / 2;
              break;
            case 'center':
              newLeftPx = canvasWidth / 2;
              break;
            case 'right':
              newLeftPx = canvasWidth - boxWidth / 2;
              break;
          }

          const newLeftPct = (newLeftPx / canvasWidth) * 100;
          selectedElement.style.left = newLeftPct + '%';

          // Update model
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.x = newLeftPct;
          }
          console.log('Aligned box horizontally to:', alignment);
        }
      }
      
      // Align Text Box Vertically (position on canvas)
      function alignBoxVertical(alignment) {
        if (selectedElement) {
          saveStateForUndo(); // Save state before aligning
          const canvas = document.getElementById('editorCanvas');
          const canvasRect = canvas.getBoundingClientRect();
          const canvasHeight = canvasRect.height;
          const boxHeight = selectedElement.offsetHeight;
          let newTopPx;

          switch(alignment) {
            case 'top':
              newTopPx = 0 + boxHeight / 2;
              break;
            case 'middle':
              newTopPx = canvasHeight / 2;
              break;
            case 'bottom':
              newTopPx = canvasHeight - boxHeight / 2;
              break;
          }

          const newTopPct = (newTopPx / canvasHeight) * 100;
          selectedElement.style.top = newTopPct + '%';

          // Update model
          const elemData = editorElements.find(el => el.id === selectedElement.id);
          if (elemData) {
            elemData.y = newTopPct;
          }
          console.log('Aligned box vertically to:', alignment);
        }
      }

      // Delete Selected Element
      function deleteSelectedElement() {
        if (selectedElement) {
          saveStateForUndo(); // Save state before deleting
          
          const index = editorElements.findIndex(el => el.id === selectedElement.id);
          if (index > -1) {
            editorElements.splice(index, 1);
          }
          selectedElement.remove();
          selectedElement = null;
        }
      }

      // RGB to Hex converter
      function rgbToHex(rgb) {
        if (rgb.startsWith('#')) return rgb;
        const result = rgb.match(/\d+/g);
        if (!result) return '#ffffff';
        return '#' + result.map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
      }

      // Save Service Slide
      function saveServiceSlide() {
        if (editorElements.length === 0) {
          console.log('No elements to save');
          return;
        }
        
        // Convert elements to service slide format (store percent positions and fontSize as vw)
        const canvas = document.getElementById('editorCanvas');
        const canvasW = canvas.clientWidth || 960;
        const slideData = {
          type: 'visual',
          service: currentEditingService,
          elements: editorElements.map(el => {
            // read live DOM element to capture percent left/top and actual font size
            const dom = document.getElementById(el.id);
            const leftPct = dom ? (parseFloat(dom.style.left) || el.x || 50) : (el.x || 50);
            const topPct = dom ? (parseFloat(dom.style.top) || el.y || 50) : (el.y || 50);
            const fontPx = dom ? (parseFloat(window.getComputedStyle(dom).fontSize) || el.fontSize || 48) : (el.fontSize || 48);

            return {
              type: el.type || 'text',
              // Prefer inner .text-content text if present
              text: dom ? ( (dom.querySelector && dom.querySelector('.text-content')) ? dom.querySelector('.text-content').innerText : dom.textContent ) : el.text,
              x: leftPct,
              y: topPct,
              // convert px font to vw based on canvas width
              fontSize: (fontPx / canvasW * 100),
              color: dom ? (dom.style.color || el.color) : el.color,
              align: dom ? (dom.style.textAlign || el.align) : el.align,
              // width/height stored as percent of canvas (if available)
              width: dom ? (parseFloat(dom.style.width) || el.width) : el.width,
              height: dom ? (parseFloat(dom.style.height) || el.height) : el.height
            };
          })
        };
        
        // If editing existing slide, include the editing index
        if (editingVisualSlideIndex >= 0) {
          slideData.editingIndex = editingVisualSlideIndex;
          console.log('Updating existing slide at index:', editingVisualSlideIndex);
          
          // If a visual slide is currently displayed, update Display2 immediately
          // Check if currentSlides has a visual slide (usually only 1 slide when displaying visual)
          if (currentSlides.length > 0 && currentSlides[currentIndex] && 
              currentSlides[currentIndex].type === 'visual') {
            console.log('Visual slide is currently displayed, refreshing Display2');
            // Update the slide in currentSlides array
            currentSlides[currentIndex] = {
              type: 'visual',
              elements: slideData.elements
            };
            // Send updated slide to projector
            const payload = { 
              type: 'visual', 
              elements: slideData.elements,
              slideIndex: currentIndex, 
              totalSlides: currentSlides.length 
            };
            console.log('Sending refresh to projector:', payload);
            ipcRenderer.send('show-slide', payload);
          }
        } else {
          console.log('Creating new visual slide');
        }
        
        console.log('Saving service slide:', slideData);
        
        // Send to main process to forward to list window
        ipcRenderer.send('save-visual-slide', slideData);
        
        // Clear and close editor
        editorElements = [];
        selectedElement = null;
        clearCanvas();
        document.getElementById('visualEditorModal').style.display = 'none';
        editingVisualSlideIndex = -1;
        editingVisualSlide = null;
      }

      // Load Existing Slide (handles all slide types)
      function loadExistingVisualSlide() {
        if (!editingVisualSlide) {
          console.log('No slide data to load');
          return;
        }
        
        const canvas = document.getElementById('editorCanvas');
        
        if (editingVisualSlide.type === 'visual' && editingVisualSlide.elements) {
          // Load existing visual slide elements
          editingVisualSlide.elements.forEach((elementData, index) => {
              const element = document.createElement('div');
              element.className = 'text-element';
              element.id = 'element-' + (elementIdCounter++);
              // inner editable content
              const contentDiv = document.createElement('div');
              contentDiv.className = 'text-content';
              contentDiv.contentEditable = true;
              contentDiv.innerText = elementData.text || '';
              element.appendChild(contentDiv);
            // Positions are stored as percent (x/y) and fontSize as vw
            element.style.left = (elementData.x !== undefined ? elementData.x : 50) + '%';
            element.style.top = (elementData.y !== undefined ? elementData.y : 50) + '%';
            const canvas = document.getElementById('editorCanvas');
            const fontPx = (elementData.fontSize !== undefined) ? ((elementData.fontSize / 100) * (canvas.clientWidth || 960)) : 48;
            element.style.fontSize = fontPx + 'px';
            element.style.color = elementData.color;
            element.style.textAlign = elementData.align;
            // Add event listeners
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('click', selectElement);
            element.addEventListener('dblclick', enterEditMode);
            contentDiv.addEventListener('input', updateElementText);
            contentDiv.addEventListener('blur', finishEditing);
            // Apply stored width/height if present (percent values)
            if (elementData.width !== undefined && elementData.width !== null) {
              element.style.width = elementData.width + '%';
            }
            if (elementData.height !== undefined && elementData.height !== null) {
              element.style.height = elementData.height + '%';
            }
            // Add resizer handles
            createResizers(element);
            canvas.appendChild(element);
            
            // Add to editor elements array (store percent coords and vw fontSize)
            editorElements.push({
              id: element.id,
              text: elementData.text,
              x: elementData.x,
              y: elementData.y,
              fontSize: elementData.fontSize, // vw units
              color: elementData.color,
              align: elementData.align,
              width: elementData.width,
              height: elementData.height,
              autoFit: elementData.autoFit !== false
            });
            // Auto-fit newly created element if enabled
            if (elementData.autoFit !== false) setTimeout(() => autoFitElement(element), 0);
          });
          console.log('Loaded', editorElements.length, 'visual elements');
          // Set toolbar font size to first element's font size if present
          const fontInput = document.getElementById('fontSize');
          if (fontInput && editorElements.length > 0) {
            fontInput.value = editorElements[0].fontSize || parseInt(fontInput.value) || 48;
          }
        } else {
          // Convert other slide types to visual elements
          let elements = [];
          
          if (editingVisualSlide.type === 'title') {
            // Convert title slide to visual elements
            if (editingVisualSlide.titleText) {
              elements.push({
                text: editingVisualSlide.titleText,
                x: 100,
                y: 200,
                fontSize: 72,
                color: '#ffffff',
                align: 'center'
              });
            }
            if (editingVisualSlide.titleSubtitle) {
              elements.push({
                text: editingVisualSlide.titleSubtitle,
                x: 100,
                y: 300,
                fontSize: 48,
                color: '#a8e063',
                align: 'center'
              });
            }
          } else if (editingVisualSlide.type === 'bible') {
            // Convert bible verse to visual elements
            if (editingVisualSlide.verseText) {
              elements.push({
                text: `"${editingVisualSlide.verseText}"`,
                x: 100,
                y: 200,
                fontSize: 48,
                color: '#ffffff',
                align: 'center'
              });
            }
            if (editingVisualSlide.reference) {
              elements.push({
                text: editingVisualSlide.reference,
                x: 100,
                y: 400,
                fontSize: 36,
                color: '#a8e063',
                align: 'center'
              });
            }
          } else {
            // Convert normal slide to visual elements (use percent positions and vw font sizes)
            const canvasW = (document.getElementById('editorCanvas') && document.getElementById('editorCanvas').clientWidth) ? document.getElementById('editorCanvas').clientWidth : 960;
            if (editingVisualSlide.position) {
              elements.push({
                text: editingVisualSlide.position,
                x: 50,
                y: 20,
                fontSize: (60 / canvasW * 100),
                color: '#ffffff',
                align: 'center'
              });
            }
            if (editingVisualSlide.title) {
              elements.push({
                text: editingVisualSlide.title,
                x: 50,
                y: 40,
                fontSize: (48 / canvasW * 100),
                color: '#a8e063',
                align: 'center'
              });
            }
            if (editingVisualSlide.name) {
              elements.push({
                text: editingVisualSlide.name,
                x: 50,
                y: 60,
                fontSize: (42 / canvasW * 100),
                color: '#ffffff',
                align: 'center'
              });
            }
          }
          
          // Create visual elements from converted data
          elements.forEach((elementData, index) => {
            const element = document.createElement('div');
            element.className = 'text-element';
            element.id = 'element-' + (elementIdCounter++);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'text-content';
            contentDiv.contentEditable = true;
            contentDiv.innerText = elementData.text || '';
            element.appendChild(contentDiv);
            // elementData.x/y are percent, fontSize is vw
            element.style.left = (elementData.x !== undefined ? elementData.x : 50) + '%';
            element.style.top = (elementData.y !== undefined ? elementData.y : 50) + '%';
            const canvas = document.getElementById('editorCanvas');
            const fontPx = (elementData.fontSize !== undefined) ? ((elementData.fontSize / 100) * (canvas.clientWidth || 960)) : 48;
            element.style.fontSize = fontPx + 'px';
            element.style.color = elementData.color;
            element.style.textAlign = elementData.align;
            // Add event listeners
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('click', selectElement);
            element.addEventListener('dblclick', enterEditMode);
            contentDiv.addEventListener('input', updateElementText);
            contentDiv.addEventListener('blur', finishEditing);
            createResizers(element);
            canvas.appendChild(element);
            
            // Add to editor elements array (store percent and vw)
            editorElements.push({
              id: element.id,
              text: elementData.text,
              x: elementData.x,
              y: elementData.y,
              fontSize: elementData.fontSize,
              color: elementData.color,
              align: elementData.align,
              width: elementData.width,
              height: elementData.height
            });
          });
          // Set toolbar font size to first converted element's font size
          const fontInput2 = document.getElementById('fontSize');
          if (fontInput2 && editorElements.length > 0) {
            fontInput2.value = editorElements[0].fontSize || parseInt(fontInput2.value) || 48;
          }
          
          console.log('Converted', editingVisualSlide.type, 'slide to', editorElements.length, 'visual elements');
        }
      }


      // Keyboard event handling for visual editor
      document.addEventListener('keydown', (e) => {
        // Only handle keys when visual editor is open
        const editorModal = document.getElementById('visualEditorModal');
        const saveBtn = document.getElementById('editor-save-btn');
        // Ctrl/Cmd+S save shortcut
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
          if (editorModal && editorModal.style.display === 'block') {
            e.preventDefault();
            // Trigger save and give visual feedback
            if (saveBtn) {
              saveBtn.classList.add('flash-save');
              setTimeout(() => saveBtn.classList.remove('flash-save'), 300);
            }
            saveServiceSlide();
            return;
          }
        }

        // Escape key: if editor open, close it; if a text element is being edited, exit edit mode instead
        if (e.key === 'Escape') {
          if (editorModal && editorModal.style.display === 'block') {
            const active = document.activeElement;
            // Consider edits when focus is inside .text-content or wrapper has editing class
            const editingWrapper = (active && active.closest) ? active.closest('.text-element') : null;
            if (editingWrapper && editingWrapper.classList && editingWrapper.classList.contains('editing')) {
              // Exit editing mode for the active text element
              editingWrapper.classList.remove('editing');
              // trigger blur to persist changes (blur inner content if focused)
              try {
                if (active && active.blur) active.blur();
                const inner = editingWrapper.querySelector('.text-content');
                if (inner && inner.blur) inner.blur();
              } catch (err) {}
              return;
            }
            e.preventDefault();
            closeVisualEditor();
            return;
          }
        }
        if (editorModal && editorModal.style.display === 'block') {
          // Undo: Ctrl+Z
          if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
            return;
          }
          
          // Redo: Ctrl+Y or Ctrl+Shift+Z
          if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'Z')) {
            e.preventDefault();
            redo();
            return;
          }
          
          if ((e.key === 'Delete' || e.key === 'Backspace')) {
            // If caret is inside an editable element, let browser handle Backspace/Delete
            const active = document.activeElement;
            // if caret is inside the inner editable content, allow native deletion
            if (active && ((active.classList && active.classList.contains('text-content')) || (active.closest && active.closest('.text-element')) )) {
              return; // allow native text deletion
            }
            e.preventDefault();
            deleteSelectedElement();
          }
        }
      });

      // Initialize
      loadBackgrounds();
      loadFonts();
    </script>
    
    <div class="copyright-footer">¬© 2025 Songnam Saraphai. All rights reserved.</div>

    <!-- Visual Editor Modal -->
    <div id="visualEditorModal" class="editor-modal">
      <div class="editor-content">
        <h2 style="margin-top:0; color:#a8e063;">üé® Visual Service Slide Editor</h2>
        
        <div class="editor-toolbar">
          <div class="toolbar-group">
            <button class="toolbar-btn" onclick="addTextElement()">‚ûï Add Text</button>
          </div>
          <div class="toolbar-group">
            <button id="toggle-grid-btn" class="toolbar-btn" onclick="toggleEditorGrid()" title="Toggle grid">üî≥ Grid</button>
          </div>
          
          <div class="toolbar-group">
            <span class="toolbar-label">Font Size:</span>
            <input type="number" id="fontSize" class="toolbar-input" value="48" min="12" max="200" onchange="updateSelectedElement()">
          </div>
          
          <div class="toolbar-group">
            <span class="toolbar-label">Color:</span>
            <input type="color" id="textColor" class="toolbar-input" value="#ffffff" onchange="updateSelectedElement()">
          </div>
          
          <!-- Removed Text Align controls -->
          
          <div class="toolbar-group">
            <span class="toolbar-label">Position Box:</span>
            <button class="toolbar-btn" onclick="alignBoxHorizontal('left')" title="Align box to left">‚¨Ö</button>
            <button class="toolbar-btn" onclick="alignBoxHorizontal('center')" title="Center box horizontally">‚Üî</button>
            <button class="toolbar-btn" onclick="alignBoxHorizontal('right')" title="Align box to right">‚û°</button>
            <button class="toolbar-btn" onclick="alignBoxVertical('top')" title="Align box to top">‚¨Ü</button>
            <button class="toolbar-btn" onclick="alignBoxVertical('middle')" title="Center box vertically">‚Üï</button>
            <button class="toolbar-btn" onclick="alignBoxVertical('bottom')" title="Align box to bottom">‚¨á</button>
          </div>
          
          <div class="toolbar-group">
            <button id="editor-save-btn" class="toolbar-btn" onclick="saveServiceSlide()">üíæ Save</button>
            <button class="toolbar-btn" onclick="closeVisualEditor()">‚ùå Close</button>
          </div>
        </div>

        <div id="editorCanvas" class="editor-canvas">
          <div id="snapGuideHorizontal" class="snap-guide horizontal"></div>
          <div id="snapGuideVertical" class="snap-guide vertical"></div>
        </div>

        <div style="margin-top:10px; color:#aaa; font-size:12px;">
          üí° <strong>Tips:</strong> <strong>Drag</strong> to move (snaps to center). <strong>Double-click</strong> to edit. <strong>Ctrl+Z</strong> to undo, <strong>Ctrl+Y</strong> to redo. <strong>Delete</strong> to remove. Use align buttons for positioning.
        </div>
      </div>
    </div>
  </body>
</html>
