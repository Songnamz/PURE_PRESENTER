<!DOCTYPE html>
<html>
  <head>
    <style>
      /* Custom Scrollbar Styling */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #000;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #7a8ef5 0%, #8659b3 100%);
      }
    </style>
  </head>
  <body style="background:black; color:white; margin:0; padding:0; overflow:hidden; height:100vh; width:100vw; background-size:cover; background-position:center; background-repeat:no-repeat;">
    <div id="lyrics" style="white-space:pre-wrap; height:100vh; width:100vw; display:flex; align-items:center; justify-content:center; line-height:1.6; padding:3vw; box-sizing:border-box; text-align:center; overflow:hidden; background:rgba(0,0,0,0.5); text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
      <div id="initial-text" style="max-height:100%; max-width:100%; overflow:hidden; font-size:10vw; font-weight:bold; letter-spacing:0.2em; font-family: Arial, sans-serif;">HAPPY SABBATH</div>
    </div>
    <script>
      const { ipcRenderer } = require('electron');
      
      // Test font availability
      function isFontAvailable(fontName) {
        const testString = 'mmmmmmmmmmlli';
        const testSize = '72px';
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        context.font = testSize + ' monospace';
        const baselineWidth = context.measureText(testString).width;
        
        context.font = testSize + ' "' + fontName + '", monospace';
        const testWidth = context.measureText(testString).width;
        
        return testWidth !== baselineWidth;
      }
      
  // Declare global variables at the top
  let fontSizeMultiplier = 1.0;
  let currentSlideData = null;
  let currentFontFamily = 'Arial';
  let originalFontSizes = new Map();
      // Debug overlay (temporary) - set to true to show center marker and bounding box
      // Default false so overlay doesn't show unless toggled
      let debugOverlay = false;

      // Toggle debug overlay with Ctrl/Cmd+I
      window.addEventListener('keydown', (e) => {
        // Ctrl+I (Windows/Linux) or Meta+I (Cmd on macOS)
        const isCtrlI = (e.ctrlKey || e.metaKey) && (e.key && e.key.toLowerCase() === 'i' || e.keyCode === 73);
        if (isCtrlI) {
          e.preventDefault();
          debugOverlay = !debugOverlay;
          if (!debugOverlay) {
            const old = document.getElementById('debug-overlay');
            if (old) old.remove();
          } else {
            // If service text present, create overlay immediately
            const inner = document.getElementById('service-text-inner');
            if (inner) {
              // create overlay similar to render-time overlay
              const old = document.getElementById('debug-overlay');
              if (old) old.remove();
              const overlay = document.createElement('div');
              overlay.id = 'debug-overlay';
              overlay.style.position = 'fixed';
              overlay.style.left = '0';
              overlay.style.top = '0';
              overlay.style.width = '100vw';
              overlay.style.height = '100vh';
              overlay.style.pointerEvents = 'none';
              overlay.style.zIndex = '100000';

              const center = document.createElement('div');
              center.style.position = 'absolute';
              center.style.left = '50%';
              center.style.top = '50%';
              center.style.width = '12px';
              center.style.height = '12px';
              center.style.marginLeft = '-6px';
              center.style.marginTop = '-6px';
              center.style.borderRadius = '50%';
              center.style.background = 'red';
              center.style.opacity = '0.8';
              overlay.appendChild(center);
              document.body.appendChild(overlay);

              setTimeout(() => {
                const rect = inner.getBoundingClientRect();
                const box = document.createElement('div');
                box.style.position = 'fixed';
                box.style.left = rect.left + 'px';
                box.style.top = rect.top + 'px';
                box.style.width = rect.width + 'px';
                box.style.height = rect.height + 'px';
                box.style.border = '2px dashed yellow';
                box.style.boxSizing = 'border-box';
                box.style.pointerEvents = 'none';
                box.style.zIndex = '100001';
                overlay.appendChild(box);

                const ic = document.createElement('div');
                ic.style.position = 'absolute';
                ic.style.left = (rect.width/2 - 4) + 'px';
                ic.style.top = (rect.height/2 - 4) + 'px';
                ic.style.width = '8px';
                ic.style.height = '8px';
                ic.style.background = 'blue';
                ic.style.borderRadius = '50%';
                ic.style.opacity = '0.9';
                box.appendChild(ic);
              }, 10);
            }
          }
        }
      });
      
      // Helper function to format font family for CSS
      function getFontFamilyCSS(fontName) {
        // If font name contains spaces or special characters, wrap in quotes
        if (!fontName) return 'Arial, sans-serif';
        
        // Always quote the font name to ensure it works properly
        return `"${fontName}", Arial, sans-serif`;
      }
      
      ipcRenderer.on('display-song', (_, data) => {
        // Store current slide data for font size adjustments
        currentSlideData = data;
        
        // Render the slide with current font size multiplier
        renderSlideWithFontSize(data);
      });

      ipcRenderer.on('update-background', (_, bgPath) => {
        if (bgPath) {
          document.body.style.backgroundImage = `url('file:///${bgPath.replace(/\\/g, '/')}')`;
        } else {
          document.body.style.backgroundImage = 'none';
        }
      });

      ipcRenderer.on('update-font', (_, fontFamily) => {
        console.log('=== FONT UPDATE RECEIVED ===');
        console.log('Old font:', currentFontFamily);
        console.log('New font:', fontFamily);
        console.log('Font available?', isFontAvailable(fontFamily));
        
        currentFontFamily = fontFamily || 'Arial';
        
        console.log('Font set to:', currentFontFamily);
        console.log('CSS will use:', getFontFamilyCSS(currentFontFamily));
        
        // Update initial text font if it's still displayed
        const initialText = document.getElementById('initial-text');
        if (initialText) {
          initialText.style.fontFamily = getFontFamilyCSS(currentFontFamily);
          console.log('Updated initial text font');
          console.log('Initial text computed font:', window.getComputedStyle(initialText).fontFamily);
        }
        
        // Re-render current slide with new font
        if (currentSlideData !== null) {
          console.log('Re-rendering current slide with new font');
          renderSlideWithFontSize(currentSlideData);
          
          // Debug: Check what font is actually being used
          setTimeout(() => {
            const lyricsDiv = document.getElementById('lyrics');
            const firstDiv = lyricsDiv.querySelector('div');
            if (firstDiv) {
              console.log('Actual computed font-family:', window.getComputedStyle(firstDiv).fontFamily);
            }
          }, 100);
        } else {
          console.log('No slide data to re-render');
        }
        
        console.log('=== FONT UPDATE COMPLETE ===');
      });

      // Display video fullscreen
      ipcRenderer.on('display-video', (_, data) => {
        const lyricsDiv = document.getElementById('lyrics');
        const videoPath = data.path.replace(/\\/g, '/');
        
        // Hide background
        document.body.style.backgroundImage = 'none';
        lyricsDiv.style.background = 'transparent';
        lyricsDiv.style.padding = '0';
        
        // Create fullscreen video element
        lyricsDiv.innerHTML = `
          <video 
            id="fullscreen-video" 
            controls 
            autoplay 
            style="width:100vw; height:100vh; object-fit:contain; display:block; background:#000;"
            src="file:///${videoPath}">
            Your browser does not support the video tag.
          </video>
        `;
      });

      // Control video playback
      ipcRenderer.on('control-video', (_, action) => {
        const video = document.getElementById('fullscreen-video');
        if (!video) {
          console.log('No video element found');
          return;
        }

        if (action === 'play') {
          video.play();
        } else if (action === 'pause') {
          video.pause();
        } else if (action === 'stop') {
          video.pause();
          video.currentTime = 0;
        }
      });

      // Font size adjustment (variables already declared at top)
      ipcRenderer.on('adjust-font-size', (_, action) => {
        if (action === 'increase') {
          fontSizeMultiplier = Math.min(fontSizeMultiplier + 0.1, 2.0); // Max 200%
        } else if (action === 'decrease') {
          fontSizeMultiplier = Math.max(fontSizeMultiplier - 0.1, 0.5); // Min 50%
        } else if (action === 'reset') {
          fontSizeMultiplier = 1.0;
        }

        // Re-render current slide with new font size
        if (currentSlideData !== null) {
          renderSlideWithFontSize(currentSlideData);
        }
      });

      // Image zoom adjustment with pan support
      let imageZoomLevel = 1.0; // Default 100%
      let imagePanX = 0; // Pan position X (percentage)
      let imagePanY = 0; // Pan position Y (percentage)
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let lastClickX = 0;
      let lastClickY = 0;

      ipcRenderer.on('adjust-image-zoom', (_, action) => {
        const img = document.querySelector('#lyrics img');
        
        if (action === 'in') {
          const prevZoom = imageZoomLevel;
          imageZoomLevel = Math.min(imageZoomLevel + 0.2, 3.0); // Max 300%
          
          // If zooming in and we have a click position, adjust pan to focus on that area
          if (img && lastClickX !== 0 && lastClickY !== 0) {
            const rect = img.getBoundingClientRect();
            const clickX = lastClickX - rect.left;
            const clickY = lastClickY - rect.top;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            // Calculate offset from center as percentage
            const offsetX = ((clickX - centerX) / rect.width) * 100;
            const offsetY = ((clickY - centerY) / rect.height) * 100;
            
            // Adjust pan to keep the clicked point centered
            imagePanX -= offsetX * (imageZoomLevel - prevZoom) * 0.5;
            imagePanY -= offsetY * (imageZoomLevel - prevZoom) * 0.5;
          }
        } else if (action === 'out') {
          imageZoomLevel = Math.max(imageZoomLevel - 0.2, 1.0); // Min 100%
          // Reset pan when zooming out to 100%
          if (imageZoomLevel === 1.0) {
            imagePanX = 0;
            imagePanY = 0;
          }
        } else if (action === 'reset') {
          imageZoomLevel = 1.0;
          imagePanX = 0;
          imagePanY = 0;
        }

        // Apply zoom and pan to image if one is displayed
        applyImageTransform();
      });

      function applyImageTransform() {
        const img = document.querySelector('#lyrics img');
        if (img) {
          img.style.transform = `scale(${imageZoomLevel}) translate(${imagePanX}%, ${imagePanY}%)`;
          img.style.transformOrigin = 'center center';
          img.style.cursor = imageZoomLevel > 1.0 ? 'grab' : 'pointer';
        }
      }

      // Track mouse position for zoom focus
      document.addEventListener('click', (e) => {
        const img = document.querySelector('#lyrics img');
        if (img && !isDragging) {
          lastClickX = e.clientX;
          lastClickY = e.clientY;
        }
      });

      // Add mouse drag support for panning zoomed images
      document.addEventListener('mousedown', (e) => {
        const img = document.querySelector('#lyrics img');
        if (img && imageZoomLevel > 1.0) {
          isDragging = true;
          dragStartX = e.clientX - imagePanX;
          dragStartY = e.clientY - imagePanY;
          img.style.cursor = 'grabbing';
          e.preventDefault();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const sensitivity = 0.5; // Adjust sensitivity
          imagePanX = (e.clientX - dragStartX) * sensitivity;
          imagePanY = (e.clientY - dragStartY) * sensitivity;
          applyImageTransform();
          e.preventDefault();
        }
      });

      document.addEventListener('mouseup', (e) => {
        if (isDragging) {
          isDragging = false;
          const img = document.querySelector('#lyrics img');
          if (img) {
            img.style.cursor = 'grab';
          }
        }
      });

      // Mouse wheel zoom support - zoom towards cursor position
      document.addEventListener('wheel', (e) => {
        const img = document.querySelector('#lyrics img');
        if (img) {
          e.preventDefault();
          
          const prevZoom = imageZoomLevel;
          
          if (e.deltaY < 0) {
            // Scroll up - Zoom in
            imageZoomLevel = Math.min(imageZoomLevel + 0.1, 3.0);
          } else {
            // Scroll down - Zoom out
            imageZoomLevel = Math.max(imageZoomLevel - 0.1, 1.0);
            // Reset pan when zooming out to 100%
            if (imageZoomLevel === 1.0) {
              imagePanX = 0;
              imagePanY = 0;
            }
          }
          
          // Zoom towards cursor position
          if (imageZoomLevel > 1.0 && prevZoom !== imageZoomLevel) {
            const rect = img.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            // Calculate offset from center as percentage
            const offsetX = ((mouseX - centerX) / rect.width) * 100;
            const offsetY = ((mouseY - centerY) / rect.height) * 100;
            
            // Adjust pan to zoom towards cursor
            const zoomDelta = imageZoomLevel - prevZoom;
            imagePanX -= offsetX * zoomDelta * 0.3;
            imagePanY -= offsetY * zoomDelta * 0.3;
          }
          
          applyImageTransform();
        }
      }, { passive: false });

      // Store current slide data whenever a new slide is displayed
      const originalDisplaySongListener = ipcRenderer.on.bind(ipcRenderer);
      
      // Helper function to render slide with current font size multiplier
      function renderSlideWithFontSize(data) {
        const lyricsDiv = document.getElementById('lyrics');
        
        console.log('Projector received data:', data);
        console.log('Current font family:', currentFontFamily);
        console.log('Font CSS:', getFontFamilyCSS(currentFontFamily));
        
        // Set font on the parent lyrics div as well
        lyricsDiv.style.fontFamily = getFontFamilyCSS(currentFontFamily);
        
        // Check if this is a visual slide
        if (typeof data === 'object' && data !== null && data.type === 'visual') {
          const elements = data.elements || [];
          // Reset background and styles
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '0';
          lyricsDiv.style.overflow = 'hidden';

          let html = '<div style="width:100vw; height:100vh; position:relative;">';
          elements.forEach((el, idx) => {
            const text = el.text || '';
            const leftPct = (el.x !== undefined) ? el.x : 50;
            const topPct = (el.y !== undefined) ? el.y : 50;
            const fontVW = (el.fontSize !== undefined) ? el.fontSize : 6; // vw
            const color = el.color || '#ffffff';
            const align = el.align || 'center';
            const fontCSS = getFontFamilyCSS(currentFontFamily);

            // If element saved a width/height (percent of editor canvas), apply similar constraints on projector.
            const elWidth = (el.width !== undefined && el.width !== null) ? el.width : null;
            const elHeight = (el.height !== undefined && el.height !== null) ? el.height : null;
            // Convert percent width to viewport units (approx): since canvas maps to viewport, use vw/vh directly
            const widthStyle = elWidth ? `width:${elWidth}vw;` : '';
            const heightStyle = elHeight ? `height:${elHeight}vh;` : '';
            html += `<div id=\"visual-el-${idx}\" style=\"position:absolute; left:${leftPct}%; top:${topPct}%; transform:translate(-50%, -50%); ${widthStyle} ${heightStyle} font-size:${fontVW}vw; color:${color}; text-align:${align}; white-space:pre-wrap; line-height:1.2; font-family:${fontCSS}; text-shadow:2px 2px 4px rgba(0,0,0,0.8); box-sizing:border-box; overflow-wrap:break-word; word-break:break-word;\">${text}</div>`;
          });
          html += '</div>';
          lyricsDiv.innerHTML = html;

          // Optional debug overlay
          if (debugOverlay) {
            const old = document.getElementById('debug-overlay');
            if (old) old.remove();
            const overlay = document.createElement('div');
            overlay.id = 'debug-overlay';
            overlay.style.position = 'fixed';
            overlay.style.left = '0';
            overlay.style.top = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '100000';

            const center = document.createElement('div');
            center.style.position = 'absolute';
            center.style.left = '50%';
            center.style.top = '50%';
            center.style.width = '12px';
            center.style.height = '12px';
            center.style.marginLeft = '-6px';
            center.style.marginTop = '-6px';
            center.style.borderRadius = '50%';
            center.style.background = 'red';
            center.style.opacity = '0.8';
            overlay.appendChild(center);
            document.body.appendChild(overlay);

            setTimeout(() => {
              elements.forEach((el, i) => {
                const dom = document.getElementById('visual-el-' + i);
                if (dom) {
                  const rect = dom.getBoundingClientRect();
                  const box = document.createElement('div');
                  box.style.position = 'fixed';
                  box.style.left = rect.left + 'px';
                  box.style.top = rect.top + 'px';
                  box.style.width = rect.width + 'px';
                  box.style.height = rect.height + 'px';
                  box.style.border = '2px dashed yellow';
                  box.style.boxSizing = 'border-box';
                  box.style.pointerEvents = 'none';
                  box.style.zIndex = '100001';
                  overlay.appendChild(box);
                }
              });
            }, 10);
          }
          return;
        }
        
        // Check if this is an image slide
        if (typeof data === 'object' && data !== null && data.type === 'image') {
          // Display image slide fullscreen (no font size adjustment needed)
          const imagePath = data.path.replace(/\\/g, '/');
          
          // Hide background image for image slides
          document.body.style.backgroundImage = 'none';
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '0';
          lyricsDiv.style.overflow = 'hidden';
          
          // Apply current zoom level and pan to the image
          const transform = `scale(${imageZoomLevel}) translate(${imagePanX}%, ${imagePanY}%)`;
          const cursor = imageZoomLevel > 1.0 ? 'grab' : 'pointer';
          lyricsDiv.innerHTML = `<img src="file:///${imagePath}" style="width:100vw; height:100vh; object-fit:contain; display:block; background:#000; transform:${transform}; transform-origin:center center; cursor:${cursor};" />`;
          return;
        }
        
        // Handle text slides
        const text = typeof data === 'string' ? data : (data && data.text ? data.text : '');
        const slideIndex = (typeof data === 'object' && data !== null) ? (data.slideIndex || 0) : 0;
        const totalSlides = (typeof data === 'object' && data !== null) ? (data.totalSlides || 1) : 1;
        const isFirstSlide = slideIndex === 0;
        
        console.log('Projector displaying text:', text.substring(0, 50), 'Index:', slideIndex);
        
        if (!text || text === '') {
          lyricsDiv.innerHTML = '<div style="max-height:100%; max-width:100%; overflow:hidden;"></div>';
          lyricsDiv.style.background = 'rgba(0,0,0,0.5)';
          return;
        }
        
        // Check if this is a service slide or Bible verse
        let isServiceSlide = false;
        let isBibleVerse = false;
        let isTitleSlide = false;
        let actualText = text;
        
        if (text.startsWith('[TITLE]\n')) {
          isTitleSlide = true;
          actualText = text.substring(8);
        } else if (text.startsWith('[SERVICE]\n')) {
          isServiceSlide = true;
          actualText = text.substring(10);
        } else if (text.startsWith('[BIBLE]\n')) {
          isBibleVerse = true;
          actualText = text.substring(8);
        }
        
        const lines = actualText.split('\n').filter(line => line.trim());
        const lineCount = lines.length;
        
        if (isTitleSlide) {
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '3vw';

          let html = '<div style="max-height:100%; max-width:100%; overflow:hidden; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh;">';

          if (lineCount === 1) {
            // Only title text
            const titleFontSize = 6 * fontSizeMultiplier;
            const fontCSS = getFontFamilyCSS(currentFontFamily);
            html += `<div style="font-size:${titleFontSize}vw; line-height:1.3; text-align:center; font-family:${fontCSS}; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em;">${lines[0]}</div>`;
          } else if (lineCount === 2) {
            // Title and subtitle
            const titleFontSize = 9 * fontSizeMultiplier;
            const subtitleFontSize = 5 * fontSizeMultiplier;
            const fontCSS = getFontFamilyCSS(currentFontFamily);
            html += `<div style="font-size:${titleFontSize}vw; line-height:1.3; text-align:center; font-family:${fontCSS}; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom:3vh;">${lines[0]}</div>`;
            html += `<div style="font-size:${subtitleFontSize}vw; line-height:1.4; text-align:center; font-family:${fontCSS}; font-weight: normal; color:#a8e063;">${lines[1]}</div>`;
          }

          html += '</div>';
          lyricsDiv.innerHTML = html;
        } else if (isServiceSlide) {
          // Render service slides using a full-size flex container so text stays centered
          // when font-size changes. This mirrors the hymnal/title layout which centers
          // content using flexbox rather than absolute positioning.
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '0';

            let serviceText = lines.join('<br>');
            let baseFontSize = 8;
            if (lineCount > 1) baseFontSize = 6;
            const fontCSS = getFontFamilyCSS(currentFontFamily);
            // outer wrapper centers at 50%/50% using translate; inner wrapper uses computed font-size instead of CSS scale
            const computedFontSize = (baseFontSize * fontSizeMultiplier);
            // Position the text element at the true center and let it grow/shrink from its center
            let html = `<div style="width:100vw; height:100vh; position:relative;">
              <div id="service-text-inner" style="position:absolute; left:50%; top:50%; transform: translate(-50%, -50%); white-space:pre-wrap; font-size:${computedFontSize}vw; text-align:center; line-height:1.2; font-family:${fontCSS}; max-width:95vw;">${serviceText}</div>
            </div>`;
            lyricsDiv.innerHTML = html;

            // Debug overlay: draw center marker and bounding box around service text
            if (debugOverlay) {
              // remove existing overlay
              const old = document.getElementById('debug-overlay');
              if (old) old.remove();
              const overlay = document.createElement('div');
              overlay.id = 'debug-overlay';
              overlay.style.position = 'fixed';
              overlay.style.left = '0';
              overlay.style.top = '0';
              overlay.style.width = '100vw';
              overlay.style.height = '100vh';
              overlay.style.pointerEvents = 'none';
              overlay.style.zIndex = '100000';

              // center marker
              const center = document.createElement('div');
              center.style.position = 'absolute';
              center.style.left = '50%';
              center.style.top = '50%';
              center.style.width = '12px';
              center.style.height = '12px';
              center.style.marginLeft = '-6px';
              center.style.marginTop = '-6px';
              center.style.borderRadius = '50%';
              center.style.background = 'red';
              center.style.opacity = '0.8';
              overlay.appendChild(center);

              document.body.appendChild(overlay);

              // bounding box around service text
              const inner = document.getElementById('service-text-inner');
              if (inner) {
                // wait a tick to ensure layout updated
                setTimeout(() => {
                  const rect = inner.getBoundingClientRect();
                  const box = document.createElement('div');
                  box.style.position = 'fixed';
                  box.style.left = rect.left + 'px';
                  box.style.top = rect.top + 'px';
                  box.style.width = rect.width + 'px';
                  box.style.height = rect.height + 'px';
                  box.style.border = '2px dashed yellow';
                  box.style.boxSizing = 'border-box';
                  box.style.pointerEvents = 'none';
                  box.style.zIndex = '100001';
                  overlay.appendChild(box);

                  // inner center marker (relative to box)
                  const ic = document.createElement('div');
                  ic.style.position = 'absolute';
                  ic.style.left = (rect.width/2 - 4) + 'px';
                  ic.style.top = (rect.height/2 - 4) + 'px';
                  ic.style.width = '8px';
                  ic.style.height = '8px';
                  ic.style.background = 'blue';
                  ic.style.borderRadius = '50%';
                  ic.style.opacity = '0.9';
                  box.appendChild(ic);
                }, 10);
              }
            }
        } else if (isBibleVerse) {
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '3vw';
          
          let html = '<div style="max-height:100%; max-width:100%; overflow:hidden; display:flex; flex-direction:column; align-items:center; justify-content:space-between; padding: 10vh 5vw;">';
          
          if (lineCount > 1) {
            const verseText = lines.slice(0, -1).join(' ');
            const reference = lines[lineCount - 1];
            
            const verseFontSize = 4 * fontSizeMultiplier;
            const refFontSize = 5 * fontSizeMultiplier;
            
            html += `<div style="font-size:${verseFontSize}vw; line-height:1.6; text-align:center; font-family:${getFontFamilyCSS(currentFontFamily)}; font-style:italic; padding: 5vh 3vw; max-width:80%;">"${verseText}"</div>`;
            html += `<div style="font-size:${refFontSize}vw; line-height:1.4; margin-top:auto; font-family:${getFontFamilyCSS(currentFontFamily)}; font-weight: bold; color:#a8e063;">${reference}</div>`;
          } else {
            const verseFontSize = 4 * fontSizeMultiplier;
            html += `<div style="font-size:${verseFontSize}vw; line-height:1.6; text-align:center; font-family:${getFontFamilyCSS(currentFontFamily)};">${lines[0]}</div>`;
          }
          
          html += '</div>';
          lyricsDiv.innerHTML = html;
        } else {
          lyricsDiv.style.background = 'rgba(0,0,0,0.5)';
          
          let baseFontSize;
          
          if (isFirstSlide) {
            if (lineCount <= 4) {
              baseFontSize = 5.5;
            } else if (lineCount <= 6) {
              baseFontSize = 4.5;
            } else {
              baseFontSize = 4;
            }
          } else {
            if (lineCount <= 4) {
              baseFontSize = 4;
            } else if (lineCount <= 6) {
              baseFontSize = 3.5;
            } else if (lineCount <= 8) {
              baseFontSize = 3;
            } else {
              baseFontSize = 2.5;
            }
          }
          
          const adjustedFontSize = baseFontSize * fontSizeMultiplier;
          const fontCSS = getFontFamilyCSS(currentFontFamily);
          console.log('Hymnal slide - Font CSS being used:', fontCSS);
          const finalHTML = `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center;"><div style="white-space:pre-wrap; font-size:${adjustedFontSize}vw; text-align:center; line-height:1.4; font-family:${fontCSS};">${text}</div></div>`;
          console.log('Hymnal HTML snippet:', finalHTML.substring(0, 200));
          lyricsDiv.innerHTML = finalHTML;
          
          // Verify the font was applied
          setTimeout(() => {
            const innerDiv = lyricsDiv.querySelector('div > div');
            if (innerDiv) {
              console.log('Applied font-family style:', innerDiv.style.fontFamily);
              console.log('Computed font-family:', window.getComputedStyle(innerDiv).fontFamily);
            }
          }, 100);
        }
      }
    </script>
  </body>
</html>
