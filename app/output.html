<!DOCTYPE html>
<html>
  <head>
    <style>
      /* Custom Scrollbar Styling */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #000;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #7a8ef5 0%, #8659b3 100%);
      }
    </style>
  </head>
  <body style="background:black; color:white; margin:0; padding:0; overflow:hidden; height:100vh; width:100vw; background-size:cover; background-position:center; background-repeat:no-repeat;">
    <div id="lyrics" style="white-space:pre-wrap; height:100vh; width:100vw; display:flex; align-items:center; justify-content:center; line-height:1.6; padding:3vw; box-sizing:border-box; text-align:center; overflow:hidden; background:rgba(0,0,0,0.5); text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
      <div id="initial-text" style="max-height:100%; max-width:100%; overflow:hidden; font-size:10vw; font-weight:bold; letter-spacing:0.2em; font-family: Arial, sans-serif;">HAPPY SABBATH</div>
    </div>
    <script>
      const { ipcRenderer } = require('electron');
      
      // Test font availability
      function isFontAvailable(fontName) {
        const testString = 'mmmmmmmmmmlli';
        const testSize = '72px';
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        context.font = testSize + ' monospace';
        const baselineWidth = context.measureText(testString).width;
        
        context.font = testSize + ' "' + fontName + '", monospace';
        const testWidth = context.measureText(testString).width;
        
        return testWidth !== baselineWidth;
      }
      
      // Declare global variables at the top
      let fontSizeMultiplier = 1.0;
      let currentSlideData = null;
      let currentFontFamily = 'Arial';
      let originalFontSizes = new Map();
      
      // Helper function to format font family for CSS
      function getFontFamilyCSS(fontName) {
        // If font name contains spaces or special characters, wrap in quotes
        if (!fontName) return 'Arial, sans-serif';
        
        // Always quote the font name to ensure it works properly
        return `"${fontName}", Arial, sans-serif`;
      }
      
      ipcRenderer.on('display-song', (_, data) => {
        // Store current slide data for font size adjustments
        currentSlideData = data;
        
        // Render the slide with current font size multiplier
        renderSlideWithFontSize(data);
      });

      ipcRenderer.on('update-background', (_, bgPath) => {
        if (bgPath) {
          document.body.style.backgroundImage = `url('file:///${bgPath.replace(/\\/g, '/')}')`;
        } else {
          document.body.style.backgroundImage = 'none';
        }
      });

      ipcRenderer.on('update-font', (_, fontFamily) => {
        console.log('=== FONT UPDATE RECEIVED ===');
        console.log('Old font:', currentFontFamily);
        console.log('New font:', fontFamily);
        console.log('Font available?', isFontAvailable(fontFamily));
        
        currentFontFamily = fontFamily || 'Arial';
        
        console.log('Font set to:', currentFontFamily);
        console.log('CSS will use:', getFontFamilyCSS(currentFontFamily));
        
        // Update initial text font if it's still displayed
        const initialText = document.getElementById('initial-text');
        if (initialText) {
          initialText.style.fontFamily = getFontFamilyCSS(currentFontFamily);
          console.log('Updated initial text font');
          console.log('Initial text computed font:', window.getComputedStyle(initialText).fontFamily);
        }
        
        // Re-render current slide with new font
        if (currentSlideData !== null) {
          console.log('Re-rendering current slide with new font');
          renderSlideWithFontSize(currentSlideData);
          
          // Debug: Check what font is actually being used
          setTimeout(() => {
            const lyricsDiv = document.getElementById('lyrics');
            const firstDiv = lyricsDiv.querySelector('div');
            if (firstDiv) {
              console.log('Actual computed font-family:', window.getComputedStyle(firstDiv).fontFamily);
            }
          }, 100);
        } else {
          console.log('No slide data to re-render');
        }
        
        console.log('=== FONT UPDATE COMPLETE ===');
      });

      // Display video fullscreen
      ipcRenderer.on('display-video', (_, data) => {
        const lyricsDiv = document.getElementById('lyrics');
        const videoPath = data.path.replace(/\\/g, '/');
        
        // Hide background
        document.body.style.backgroundImage = 'none';
        lyricsDiv.style.background = 'transparent';
        lyricsDiv.style.padding = '0';
        
        // Create fullscreen video element
        lyricsDiv.innerHTML = `
          <video 
            id="fullscreen-video" 
            controls 
            autoplay 
            style="width:100vw; height:100vh; object-fit:contain; display:block; background:#000;"
            src="file:///${videoPath}">
            Your browser does not support the video tag.
          </video>
        `;
      });

      // Control video playback
      ipcRenderer.on('control-video', (_, action) => {
        const video = document.getElementById('fullscreen-video');
        if (!video) {
          console.log('No video element found');
          return;
        }

        if (action === 'play') {
          video.play();
        } else if (action === 'pause') {
          video.pause();
        } else if (action === 'stop') {
          video.pause();
          video.currentTime = 0;
        }
      });

      // Font size adjustment (variables already declared at top)
      ipcRenderer.on('adjust-font-size', (_, action) => {
        if (action === 'increase') {
          fontSizeMultiplier = Math.min(fontSizeMultiplier + 0.1, 2.0); // Max 200%
        } else if (action === 'decrease') {
          fontSizeMultiplier = Math.max(fontSizeMultiplier - 0.1, 0.5); // Min 50%
        } else if (action === 'reset') {
          fontSizeMultiplier = 1.0;
        }

        // Re-render current slide with new font size
        if (currentSlideData !== null) {
          renderSlideWithFontSize(currentSlideData);
        }
      });

      // Image zoom adjustment with pan support
      let imageZoomLevel = 1.0; // Default 100%
      let imagePanX = 0; // Pan position X (percentage)
      let imagePanY = 0; // Pan position Y (percentage)
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let lastClickX = 0;
      let lastClickY = 0;

      ipcRenderer.on('adjust-image-zoom', (_, action) => {
        const img = document.querySelector('#lyrics img');
        
        if (action === 'in') {
          const prevZoom = imageZoomLevel;
          imageZoomLevel = Math.min(imageZoomLevel + 0.2, 3.0); // Max 300%
          
          // If zooming in and we have a click position, adjust pan to focus on that area
          if (img && lastClickX !== 0 && lastClickY !== 0) {
            const rect = img.getBoundingClientRect();
            const clickX = lastClickX - rect.left;
            const clickY = lastClickY - rect.top;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            // Calculate offset from center as percentage
            const offsetX = ((clickX - centerX) / rect.width) * 100;
            const offsetY = ((clickY - centerY) / rect.height) * 100;
            
            // Adjust pan to keep the clicked point centered
            imagePanX -= offsetX * (imageZoomLevel - prevZoom) * 0.5;
            imagePanY -= offsetY * (imageZoomLevel - prevZoom) * 0.5;
          }
        } else if (action === 'out') {
          imageZoomLevel = Math.max(imageZoomLevel - 0.2, 1.0); // Min 100%
          // Reset pan when zooming out to 100%
          if (imageZoomLevel === 1.0) {
            imagePanX = 0;
            imagePanY = 0;
          }
        } else if (action === 'reset') {
          imageZoomLevel = 1.0;
          imagePanX = 0;
          imagePanY = 0;
        }

        // Apply zoom and pan to image if one is displayed
        applyImageTransform();
      });

      function applyImageTransform() {
        const img = document.querySelector('#lyrics img');
        if (img) {
          img.style.transform = `scale(${imageZoomLevel}) translate(${imagePanX}%, ${imagePanY}%)`;
          img.style.transformOrigin = 'center center';
          img.style.cursor = imageZoomLevel > 1.0 ? 'grab' : 'pointer';
        }
      }

      // Track mouse position for zoom focus
      document.addEventListener('click', (e) => {
        const img = document.querySelector('#lyrics img');
        if (img && !isDragging) {
          lastClickX = e.clientX;
          lastClickY = e.clientY;
        }
      });

      // Add mouse drag support for panning zoomed images
      document.addEventListener('mousedown', (e) => {
        const img = document.querySelector('#lyrics img');
        if (img && imageZoomLevel > 1.0) {
          isDragging = true;
          dragStartX = e.clientX - imagePanX;
          dragStartY = e.clientY - imagePanY;
          img.style.cursor = 'grabbing';
          e.preventDefault();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const sensitivity = 0.5; // Adjust sensitivity
          imagePanX = (e.clientX - dragStartX) * sensitivity;
          imagePanY = (e.clientY - dragStartY) * sensitivity;
          applyImageTransform();
          e.preventDefault();
        }
      });

      document.addEventListener('mouseup', (e) => {
        if (isDragging) {
          isDragging = false;
          const img = document.querySelector('#lyrics img');
          if (img) {
            img.style.cursor = 'grab';
          }
        }
      });

      // Mouse wheel zoom support - zoom towards cursor position
      document.addEventListener('wheel', (e) => {
        const img = document.querySelector('#lyrics img');
        if (img) {
          e.preventDefault();
          
          const prevZoom = imageZoomLevel;
          
          if (e.deltaY < 0) {
            // Scroll up - Zoom in
            imageZoomLevel = Math.min(imageZoomLevel + 0.1, 3.0);
          } else {
            // Scroll down - Zoom out
            imageZoomLevel = Math.max(imageZoomLevel - 0.1, 1.0);
            // Reset pan when zooming out to 100%
            if (imageZoomLevel === 1.0) {
              imagePanX = 0;
              imagePanY = 0;
            }
          }
          
          // Zoom towards cursor position
          if (imageZoomLevel > 1.0 && prevZoom !== imageZoomLevel) {
            const rect = img.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            // Calculate offset from center as percentage
            const offsetX = ((mouseX - centerX) / rect.width) * 100;
            const offsetY = ((mouseY - centerY) / rect.height) * 100;
            
            // Adjust pan to zoom towards cursor
            const zoomDelta = imageZoomLevel - prevZoom;
            imagePanX -= offsetX * zoomDelta * 0.3;
            imagePanY -= offsetY * zoomDelta * 0.3;
          }
          
          applyImageTransform();
        }
      }, { passive: false });

      // Store current slide data whenever a new slide is displayed
      const originalDisplaySongListener = ipcRenderer.on.bind(ipcRenderer);
      
      // Helper function to render slide with current font size multiplier
      function renderSlideWithFontSize(data) {
        const lyricsDiv = document.getElementById('lyrics');
        
        console.log('Projector received data:', data);
        console.log('Current font family:', currentFontFamily);
        console.log('Font CSS:', getFontFamilyCSS(currentFontFamily));
        
        // Set font on the parent lyrics div as well
        lyricsDiv.style.fontFamily = getFontFamilyCSS(currentFontFamily);
        
        // Check if this is a visual slide
        if (typeof data === 'object' && data !== null && data.type === 'visual') {
          // Display visual slide with custom elements
          const elements = data.elements || [];
          
          // Reset background and styles
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '0';
          lyricsDiv.style.overflow = 'hidden';
          
          // Create container for visual elements
          let html = '<div style="position:relative; width:100vw; height:100vh; overflow:hidden;">';
          
          // Render each text element
          elements.forEach((element) => {
            const text = element.text || '';
            const x = element.x || 0;
            const y = element.y || 0;
            const fontSize = (element.fontSize || 48);
            const color = element.color || '#ffffff';
            const align = element.align || 'center';
            
            // Scale coordinates from editor (1000x600) to fullscreen
            const scaleX = 100 / 1000; // Convert to vw
            const scaleY = 100 / 600;  // Convert to vh
            const scaledX = x * scaleX;
            const scaledY = y * scaleY;
            // Apply global font size multiplier so projector font controls affect visual slides
            const scaledFontSize = (fontSize / 1000) * 100 * fontSizeMultiplier; // Convert to vw units and scale
            const fontCSS = getFontFamilyCSS(currentFontFamily);

            // Estimate element width in vw if width not provided (approx char * font-size * factor)
            const estElemWidthVW = Math.min(100 - scaledX, (text.length * scaledFontSize * 0.55));

            // Positioning: anchor based on alignment so resizing keeps visual center
            let leftPos = scaledX; // default left
            let transform = 'translate(-0%, -50%)';
            if (align === 'center') {
              // center by moving left to center point and translate -50%
              leftPos = scaledX + estElemWidthVW / 2;
              transform = 'translate(-50%, -50%)';
            } else if (align === 'right') {
              // right-align: anchor to right edge
              leftPos = scaledX + estElemWidthVW;
              transform = 'translate(-100%, -50%)';
            } else {
              // left-align: keep left as-is, vertically center
              leftPos = scaledX;
              transform = 'translate(0%, -50%)';
            }

            html += `<div style="position:absolute; left:${leftPos}vw; top:${scaledY}vh; transform:${transform}; transform-origin:center center; font-size:${scaledFontSize}vw; color:${color}; text-align:${align}; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); white-space:pre-wrap; max-width:${estElemWidthVW}vw; font-family:${fontCSS};">${text}</div>`;
          });
          
          html += '</div>';
          lyricsDiv.innerHTML = html;
          return;
        }
        
        // Check if this is an image slide
        if (typeof data === 'object' && data !== null && data.type === 'image') {
          // Display image slide fullscreen (no font size adjustment needed)
          const imagePath = data.path.replace(/\\/g, '/');
          
          // Hide background image for image slides
          document.body.style.backgroundImage = 'none';
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '0';
          lyricsDiv.style.overflow = 'hidden';
          
          // Apply current zoom level and pan to the image
          const transform = `scale(${imageZoomLevel}) translate(${imagePanX}%, ${imagePanY}%)`;
          const cursor = imageZoomLevel > 1.0 ? 'grab' : 'pointer';
          lyricsDiv.innerHTML = `<img src="file:///${imagePath}" style="width:100vw; height:100vh; object-fit:contain; display:block; background:#000; transform:${transform}; transform-origin:center center; cursor:${cursor};" />`;
          return;
        }
        
        // Handle text slides
        const text = typeof data === 'string' ? data : (data && data.text ? data.text : '');
        const slideIndex = (typeof data === 'object' && data !== null) ? (data.slideIndex || 0) : 0;
        const totalSlides = (typeof data === 'object' && data !== null) ? (data.totalSlides || 1) : 1;
        const isFirstSlide = slideIndex === 0;
        
        console.log('Projector displaying text:', text.substring(0, 50), 'Index:', slideIndex);
        
        if (!text || text === '') {
          lyricsDiv.innerHTML = '<div style="max-height:100%; max-width:100%; overflow:hidden;"></div>';
          lyricsDiv.style.background = 'rgba(0,0,0,0.5)';
          return;
        }
        
        // Check if this is a service slide or Bible verse
        let isServiceSlide = false;
        let isBibleVerse = false;
        let isTitleSlide = false;
        let actualText = text;
        
        if (text.startsWith('[TITLE]\n')) {
          isTitleSlide = true;
          actualText = text.substring(8);
        } else if (text.startsWith('[SERVICE]\n')) {
          isServiceSlide = true;
          actualText = text.substring(10);
        } else if (text.startsWith('[BIBLE]\n')) {
          isBibleVerse = true;
          actualText = text.substring(8);
        }
        
        const lines = actualText.split('\n').filter(line => line.trim());
        const lineCount = lines.length;
        
        if (isTitleSlide) {
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '3vw';

          let html = '<div style="max-height:100%; max-width:100%; overflow:hidden; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh;">';

          if (lineCount === 1) {
            // Only title text
            const titleFontSize = 6 * fontSizeMultiplier;
            const fontCSS = getFontFamilyCSS(currentFontFamily);
            html += `<div style="font-size:${titleFontSize}vw; line-height:1.3; text-align:center; font-family:${fontCSS}; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em;">${lines[0]}</div>`;
          } else if (lineCount === 2) {
            // Title and subtitle
            const titleFontSize = 9 * fontSizeMultiplier;
            const subtitleFontSize = 5 * fontSizeMultiplier;
            const fontCSS = getFontFamilyCSS(currentFontFamily);
            html += `<div style="font-size:${titleFontSize}vw; line-height:1.3; text-align:center; font-family:${fontCSS}; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom:3vh;">${lines[0]}</div>`;
            html += `<div style="font-size:${subtitleFontSize}vw; line-height:1.4; text-align:center; font-family:${fontCSS}; font-weight: normal; color:#a8e063;">${lines[1]}</div>`;
          }

          html += '</div>';
          lyricsDiv.innerHTML = html;
        } else if (isServiceSlide) {
          // Render service slides using a full-size flex container so text stays centered
          // when font-size changes. This mirrors the hymnal/title layout which centers
          // content using flexbox rather than absolute positioning.
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '3vw';

          let html = '<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center;">';
          html += '<div style="display:flex; flex-direction:column; align-items:center; justify-content:center; gap:0; box-sizing:border-box; max-width:95vw; padding:0 2.5vw;">';

          lines.forEach((line, index) => {
            let baseFontSize, content, marginBottom, marginTop;

            if (index === 0) {
              baseFontSize = 8;
              content = line;
              marginBottom = '0';
              marginTop = '0';
            } else if (index === 1 && lineCount === 3) {
              baseFontSize = 6;
              content = `"${line}"`;
              marginBottom = '3vw';
              marginTop = '2vw';
            } else if (index === 1 && lineCount === 2) {
              baseFontSize = 6;
              content = line;
              marginTop = '2vw';
              marginBottom = '0';
            } else {
              baseFontSize = 6;
              content = line;
              marginBottom = '0';
              marginTop = '0';
            }

            const adjustedFontSize = baseFontSize * fontSizeMultiplier;
            const fontCSS = getFontFamilyCSS(currentFontFamily);
            // Child lines are not given a fixed width so they size to their content and
            // remain centered by the column flex container. This prevents asymmetric
            // movement when font-size changes.
            html += `<div style="font-size:${adjustedFontSize}vw; line-height:1.4; margin-bottom:${marginBottom}; margin-top:${marginTop}; font-family:${fontCSS}; font-weight: normal; text-align:center; white-space:pre-wrap;">${content}</div>`;
          });

          html += '</div></div>';
          lyricsDiv.innerHTML = html;
        } else if (isBibleVerse) {
          lyricsDiv.style.background = 'transparent';
          lyricsDiv.style.padding = '3vw';
          
          let html = '<div style="max-height:100%; max-width:100%; overflow:hidden; display:flex; flex-direction:column; align-items:center; justify-content:space-between; padding: 10vh 5vw;">';
          
          if (lineCount > 1) {
            const verseText = lines.slice(0, -1).join(' ');
            const reference = lines[lineCount - 1];
            
            const verseFontSize = 4 * fontSizeMultiplier;
            const refFontSize = 5 * fontSizeMultiplier;
            
            html += `<div style="font-size:${verseFontSize}vw; line-height:1.6; text-align:center; font-family:${getFontFamilyCSS(currentFontFamily)}; font-style:italic; padding: 5vh 3vw; max-width:80%;">"${verseText}"</div>`;
            html += `<div style="font-size:${refFontSize}vw; line-height:1.4; margin-top:auto; font-family:${getFontFamilyCSS(currentFontFamily)}; font-weight: bold; color:#a8e063;">${reference}</div>`;
          } else {
            const verseFontSize = 4 * fontSizeMultiplier;
            html += `<div style="font-size:${verseFontSize}vw; line-height:1.6; text-align:center; font-family:${getFontFamilyCSS(currentFontFamily)};">${lines[0]}</div>`;
          }
          
          html += '</div>';
          lyricsDiv.innerHTML = html;
        } else {
          lyricsDiv.style.background = 'rgba(0,0,0,0.5)';
          
          let baseFontSize;
          
          if (isFirstSlide) {
            if (lineCount <= 4) {
              baseFontSize = 5.5;
            } else if (lineCount <= 6) {
              baseFontSize = 4.5;
            } else {
              baseFontSize = 4;
            }
          } else {
            if (lineCount <= 4) {
              baseFontSize = 4;
            } else if (lineCount <= 6) {
              baseFontSize = 3.5;
            } else if (lineCount <= 8) {
              baseFontSize = 3;
            } else {
              baseFontSize = 2.5;
            }
          }
          
          const adjustedFontSize = baseFontSize * fontSizeMultiplier;
          const fontCSS = getFontFamilyCSS(currentFontFamily);
          console.log('Hymnal slide - Font CSS being used:', fontCSS);
          const finalHTML = `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center;"><div style="white-space:pre-wrap; font-size:${adjustedFontSize}vw; text-align:center; line-height:1.4; font-family:${fontCSS};">${text}</div></div>`;
          console.log('Hymnal HTML snippet:', finalHTML.substring(0, 200));
          lyricsDiv.innerHTML = finalHTML;
          
          // Verify the font was applied
          setTimeout(() => {
            const innerDiv = lyricsDiv.querySelector('div > div');
            if (innerDiv) {
              console.log('Applied font-family style:', innerDiv.style.fontFamily);
              console.log('Computed font-family:', window.getComputedStyle(innerDiv).fontFamily);
            }
          }, 100);
        }
      }
    </script>
  </body>
</html>
